CCS PCD C Compiler, Version 5.015, 5967               03-Nov-17 22:07

               Filename:   D:\chin\mine BCH project\Module6-7\Embeded\Project\main\QuadEncoder.lst

               ROM used:   4592 bytes (14%)
                           Largest free fragment is 26124
               RAM used:   298 (4%) at main() level
                           390 (5%) worst case
               Stack size: 128

*
0C00:  GOTO    1C92
*
0C44:  GOTO    11EE
*
0C90:  GOTO    E22
0C94:  GOTO    F5C
.................... /* 
.................... *************************** C SOURCE FILE ************************************ 
....................  
.................... project   : 
.................... filename  : QuadEncoder.C 
.................... version   : 1 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 1/11/2017 
.................... Revised by   :  
.................... Description  : 
....................  
.................... ---------------------------- 
.................... Version      : 2 
.................... Date         : 3/11/2017 
.................... Revised by   :  
.................... Description  : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #define QuadEncoder_C_SRC 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             MODULES USED                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "QuadEncoder.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : QuadEncoder.H 
.................... version   : 1 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 1/11/2017 
.................... Revised by   : 
.................... Description  : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef QuadEncoder_INCLUDED 
.................... #define QuadEncoder_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "CONFIG_PIC24.H"  
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
0DFC:  CLR     32
0DFE:  MOV     #E08,W3
0E00:  ADD     W3,W0,W0
0E02:  TBLRDL.B[W0],W0L
0E04:  CLR.B   1
0E06:  RETURN  
0E08:  DATA    65,3A,00
0E0A:  DATA    20,25,00
0E0C:  DATA    64,2C,00
0E0E:  DATA    20,75,00
0E10:  DATA    3A,20,00
0E12:  DATA    25,64,00
0E14:  DATA    20,2C,00
0E16:  DATA    50,75,00
0E18:  DATA    6C,73,00
0E1A:  DATA    65,3A,00
0E1C:  DATA    20,25,00
0E1E:  DATA    64,0D,00
0E20:  DATA    0A,00,00
*
1096:  MOV     W6,[W15++]
1098:  MOV     W7,[W15++]
109A:  MOV     W8,[W15++]
109C:  MOV     W9,[W15++]
109E:  CLR     W4
10A0:  CLR     W5
10A2:  CLR     W6
10A4:  CLR     W7
10A6:  XOR     W2,W3,W8
10A8:  BRA     Z,10CC
10AA:  MOV     #20,W8
10AC:  BCLR.B  42.0
10AE:  RLC     W0,W0
10B0:  RLC     W1,W1
10B2:  RLC     W4,W4
10B4:  RLC     W5,W5
10B6:  CP      W5,W3
10B8:  BRA     NZ,10BC
10BA:  CPB     W4,W2
10BC:  BRA     NC,10C4
10BE:  SUB     W4,W2,W4
10C0:  SUBB    W5,W3,W5
10C2:  BSET.B  42.0
10C4:  RLC     W6,W6
10C6:  RLC     W7,W7
10C8:  DEC     W8,W8
10CA:  BRA     NZ,10AC
10CC:  MOV     W7,W1
10CE:  MOV     W6,W0
10D0:  MOV     [--W15],W9
10D2:  MOV     [--W15],W8
10D4:  MOV     [--W15],W7
10D6:  MOV     [--W15],W6
10D8:  RETURN  
10DA:  MOV     W5,[W15++]
10DC:  MOV     #C,W5
10DE:  REPEAT  #7
10E0:  MOV     [W5++],[W15++]
10E2:  BTSS    W1.F
10E4:  BRA     10F4
10E6:  NEG     W0,W0
10E8:  BRA     Z,10EC
10EA:  BRA     NZ,10F0
10EC:  NEG     W1,W1
10EE:  BRA     10F2
10F0:  COM     W1,W1
10F2:  BSET    W4.8
10F4:  CLR     W5
10F6:  MOV     W0,W6
10F8:  MOV     W1,W7
10FA:  MOV     W4,W12
10FC:  BCLR    W4.F
10FE:  CP0.B   W4L
1100:  BRA     NZ,1104
1102:  BRA     1134
1104:  SUB.B   W4L,#B,W5L
1106:  BRA     NC,1134
1108:  SUB.B   W4L,W5L,W4L
110A:  BTSS    W12.F
110C:  BRA     1124
110E:  BTSS    W4.8
1110:  BRA     1120
1112:  MOV     #2D,W0
1114:  BTSC.B  223.1
1116:  BRA     1114
1118:  MOV     W0,224
111A:  BCLR    W4.8
111C:  DEC     W5,W5
111E:  BRA     N,1134
1120:  MOV     #30,W0
1122:  BRA     1126
1124:  MOV     #20,W0
1126:  BTSC.B  223.1
1128:  BRA     1126
112A:  MOV     W0,224
112C:  DEC     W5,W5
112E:  BRA     NN,1126
1130:  BTSC    W4.8
1132:  DEC.B   W4L,W4L
1134:  MOV     #E,W8
1136:  MOV     #0,W9
1138:  LNK     #10
113A:  MOV     W12,[W14+W8]
113C:  DEC2    W8,W8
113E:  BRA     NN,113A
1140:  MOV     W4,W5
1142:  MOV     #A,W4
1144:  BTSC    W5.8
1146:  INC     W4,W4
1148:  BSET    W5.E
114A:  BTSC    W12.F
114C:  BSET    W5.F
114E:  CP0.B   W5L
1150:  BRA     Z,1154
1152:  DEC.B   W5L,W5L
1154:  MOV     W4,[W14]
1156:  MOV     W5,[W14+#2]
1158:  MOV     W6,W0
115A:  MOV     W7,W1
115C:  MOV     #CA00,W2
115E:  MOV     #3B9A,W3
1160:  MOV     #2710,W8
1162:  BCLR    W13.F
1164:  BCLR.B  43.0
1166:  CALL    1096
116A:  BTG     W13.F
116C:  BTSC    W13.F
116E:  BRA     117E
1170:  MOV     W0,[W14+#8]
1172:  MOV     W1,[W14+#A]
1174:  MOV     W0,W2
1176:  MOV     W1,W3
1178:  MOV     [W14+#4],W0
117A:  MOV     [W14+#6],W1
117C:  BRA     1164
117E:  MOV     W2,[W14+#8]
1180:  MOV     W3,[W14+#A]
1182:  MOV     W4,[W14+#4]
1184:  MOV     W5,[W14+#6]
1186:  MOV     [W14],W4
1188:  MOV     [W14+#2],W5
118A:  MOV     #30,W6
118C:  CP0     W0
118E:  BRA     NZ,11B2
1190:  BTSS    W5.E
1192:  BRA     11B6
1194:  DEC     W4,W4
1196:  MOV     W4,[W14]
1198:  CP0     W4
119A:  BRA     Z,11B6
119C:  CP.B    W4L,W5L
119E:  BRA     Z,11A4
11A0:  BTSC.B  42.0
11A2:  BRA     11D4
11A4:  BTSS    W5.F
11A6:  BRA     11AE
11A8:  BTSS    W5.8
11AA:  BRA     11CC
11AC:  BRA     11BC
11AE:  MOV     #20,W6
11B0:  BRA     11CC
11B2:  BCLR    W5.E
11B4:  MOV     W5,[W14+#2]
11B6:  MOV     [W14+#2],W5
11B8:  BTSS    W5.8
11BA:  BRA     11CC
11BC:  BCLR    W5.8
11BE:  MOV     W5,[W14+#2]
11C0:  MOV     W0,W10
11C2:  MOV     #2D,W0
11C4:  BTSC.B  223.1
11C6:  BRA     11C4
11C8:  MOV     W0,224
11CA:  MOV     W10,W0
11CC:  ADD.B   W6L,W0L,W0L
11CE:  BTSC.B  223.1
11D0:  BRA     11CE
11D2:  MOV     W0,224
11D4:  MOV     [W14+#8],W0
11D6:  MOV     [W14+#A],W1
11D8:  MOV     #A,W2
11DA:  CLR     W3
11DC:  CP      W0,#1
11DE:  BRA     Z,11E2
11E0:  BRA     1164
11E2:  ULNK    
11E4:  MOV     #1A,W5
11E6:  REPEAT  #7
11E8:  MOV     [--W15],[W5--]
11EA:  MOV     [--W15],W5
11EC:  RETURN  
*
13C0:  MOV     W5,[W15++]
13C2:  MOV     #C,W5
13C4:  REPEAT  #3
13C6:  MOV     [W5++],[W15++]
13C8:  MUL.UU  W0,W2,W4
13CA:  MUL.UU  W0,W3,W6
13CC:  BCLR.B  42.0
13CE:  ADD     W6,W5,W5
13D0:  ADDC    W7,#0,W8
13D2:  MUL.UU  W1,W2,W6
13D4:  ADDC    W6,W5,W5
13D6:  ADDC    W7,W8,W8
13D8:  MUL.UU  W1,W3,W6
13DA:  ADD     W6,W8,W8
13DC:  ADDC    #0,W7
13DE:  MOV     W7,W3
13E0:  MOV     W8,W2
13E2:  MOV     W5,W1
13E4:  MOV     W4,W0
13E6:  MOV     #12,W5
13E8:  REPEAT  #3
13EA:  MOV     [--W15],[W5--]
13EC:  MOV     [--W15],W5
13EE:  RETURN  
13F0:  MOV     W5,[W15++]
13F2:  MOV     #C,W5
13F4:  REPEAT  #3
13F6:  MOV     [W5++],[W15++]
13F8:  MOV     W0,W4
13FA:  MOV     W1,W5
13FC:  MOV     W2,W6
13FE:  MOV     W3,W7
1400:  CLR     W0
1402:  CLR     W1
1404:  CLR     W2
1406:  CLR     W3
1408:  BCLR    W8.0
140A:  BTSS    W7.F
140C:  BRA     1418
140E:  BSET    W8.0
1410:  NEG     W4,W4
1412:  COM     W5,W5
1414:  COM     W6,W6
1416:  COM     W7,W7
1418:  IOR      W4,  W5,W9
141A:  BRA     NZ,1420
141C:  IOR      W6,  W7,W9
141E:  BRA     Z,144A
1420:  MOV     #473,W9
1422:  BTSC    W3.4
1424:  BRA     143C
1426:  BCLR.B  42.0
1428:  RLC     W4,W4
142A:  RLC     W5,W5
142C:  RLC     W6,W6
142E:  RLC     W7,W7
1430:  RLC     W0,W0
1432:  RLC     W1,W1
1434:  RLC     W2,W2
1436:  RLC     W3,W3
1438:  DEC     W9,W9
143A:  BRA     NZ,1422
143C:  SL      W9,#4,W9
143E:  BCLR.B  42.0
1440:  BCLR    W9.F
1442:  BCLR    W3.4
1444:  XOR     W9,W3,W3
1446:  BTSC    W8.0
1448:  BSET    W3.F
144A:  MOV     #12,W5
144C:  REPEAT  #3
144E:  MOV     [--W15],[W5--]
1450:  MOV     [--W15],W5
1452:  RETURN  
1454:  MOV     W8,[W15++]
1456:  MOV     #12,W8
1458:  REPEAT  #4
145A:  MOV     [W8++],[W15++]
145C:  XOR     W3,W7,W13
145E:  MOV     W3,W8
1460:  MOV     W7,W9
1462:  MOV     #7FF,W10
1464:  BCLR.B  42.0
1466:  BCLR.B  42.1
1468:  ASR     W8,#4,W8
146A:  AND     W10,W8,W8
146C:  CP0     W8
146E:  BRA     Z,1548
1470:  BCLR.B  42.0
1472:  BCLR.B  42.1
1474:  ASR     W9,#4,W9
1476:  AND     W10,W9,W9
1478:  CP0     W9
147A:  BRA     Z,1548
147C:  CLR     W10
147E:  SUB     W8,W9,W12
1480:  BRA     NC,1488
1482:  ADD     #3FF,W12
1484:  BRA     C,1548
1486:  BRA     1490
1488:  MOV     #401,W11
148A:  SUB     W12,W11,W12
148C:  BRA     NC,1548
148E:  BRA     Z,1548
1490:  CLR     W8
1492:  CLR     W9
1494:  CLR     W10
1496:  CLR     W11
1498:  AND     #1F,W3
149A:  BSET    W3.4
149C:  AND     #1F,W7
149E:  BSET    W7.4
14A0:  MOV     W12,[W15++]
14A2:  MOV     #36,W12
14A4:  SUB     W0,W4,W0
14A6:  SUBB    W1,W5,W1
14A8:  SUBB    W2,W6,W2
14AA:  SUBB    W3,W7,W3
14AC:  BRA     N,14B2
14AE:  BRA     C,14BC
14B0:  BRA     NZ,14BE
14B2:  ADD     W0,W4,W0
14B4:  ADDC    W1,W5,W1
14B6:  ADDC    W2,W6,W2
14B8:  ADDC    W3,W7,W3
14BA:  BRA     14BE
14BC:  BSET    W8.0
14BE:  DEC     W12,W12
14C0:  BRA     Z,14D8
14C2:  BCLR.B  42.0
14C4:  RLC     W0,W0
14C6:  RLC     W1,W1
14C8:  RLC     W2,W2
14CA:  RLC     W3,W3
14CC:  BCLR.B  42.0
14CE:  RLC     W8,W8
14D0:  RLC     W9,W9
14D2:  RLC     W10,W10
14D4:  RLC     W11,W11
14D6:  BRA     14A4
14D8:  MOV     [--W15],W12
14DA:  BTSC    W11.5
14DC:  BRA     14E0
14DE:  BRA     14EC
14E0:  BCLR.B  42.0
14E2:  RRC     W11,W11
14E4:  RRC     W10,W10
14E6:  RRC     W9,W9
14E8:  RRC     W8,W8
14EA:  BRA     14F2
14EC:  DEC     W12,W12
14EE:  BCLR.B  42.0
14F0:  BRA     Z,1548
14F2:  BTSC.B  42.0
14F4:  BRA     1508
14F6:  RLC     W0,W0
14F8:  RLC     W1,W1
14FA:  RLC     W2,W2
14FC:  RLC     W3,W3
14FE:  SUB     W0,W4,W4
1500:  SUBB    W1,W5,W5
1502:  SUBB    W2,W6,W6
1504:  SUBB    W3,W7,W7
1506:  BRA     NC,1532
1508:  INC     W8,W8
150A:  BRA     NZ,1532
150C:  INC     W9,W9
150E:  BRA     NZ,1532
1510:  INC     W10,W10
1512:  BRA     NZ,1532
1514:  INC     W11,W11
1516:  BRA     NZ,1532
1518:  INC     W12,W12
151A:  BRA     Z,1548
151C:  BRA     1532
151E:  DEC     W12,W12
1520:  BRA     Z,1548
1522:  BTSC    W11.4
1524:  BRA     1532
1526:  BCLR.B  42.0
1528:  RLC     W8,W8
152A:  RLC     W9,W9
152C:  RLC     W10,W10
152E:  RLC     W11,W11
1530:  BRA     1522
1532:  SL      W12,#4,W12
1534:  BCLR.B  42.0
1536:  BCLR    W12.F
1538:  BTSC    W13.F
153A:  BSET    W12.F
153C:  BCLR    W11.4
153E:  XOR     W12,W11,W3
1540:  MOV     W10,W2
1542:  MOV     W9,W1
1544:  MOV     W8,W0
1546:  BRA     1552
1548:  MOV     #0,W0
154A:  MOV     #0,W1
154C:  MOV     #0,W2
154E:  MOV     #0,W3
1550:  BRA     1552
1552:  MOV     #1A,W8
1554:  REPEAT  #4
1556:  MOV     [--W15],[W8--]
1558:  MOV     [--W15],W8
155A:  RETURN  
155C:  MOV     W5,[W15++]
155E:  MOV     #C,W5
1560:  REPEAT  #5
1562:  MOV     [W5++],[W15++]
1564:  MOV     W3,W8
1566:  MOV     W2,W7
1568:  MOV     W1,W6
156A:  MOV     W0,W5
156C:  MOV     W3,W9
156E:  MOV     #473,W11
1570:  ASR     W3,#4,W3
1572:  MOV     #7FF,W10
1574:  AND     W10,W3,W3
1576:  SUB     W11,W3,W11
1578:  AND     #1F,W8
157A:  BSET    W8.4
157C:  CLR     W0
157E:  CLR     W1
1580:  CLR     W2
1582:  CLR     W3
1584:  BCLR.B  42.0
1586:  RRC     W8,W8
1588:  RRC     W7,W7
158A:  RRC     W6,W6
158C:  RRC     W5,W5
158E:  RRC     W3,W3
1590:  RRC     W2,W2
1592:  RRC     W1,W1
1594:  RRC     W0,W0
1596:  DEC     W11,W11
1598:  BRA     NZ,1584
159A:  BTSS    W9.F
159C:  BRA     15A8
159E:  NEG     W0,W0
15A0:  COM     W1,W1
15A2:  COM     W2,W2
15A4:  COM     W3,W3
15A6:  BRA     15A8
15A8:  MOV     #16,W5
15AA:  REPEAT  #5
15AC:  MOV     [--W15],[W5--]
15AE:  MOV     [--W15],W5
15B0:  RETURN  
15B2:  MOV     W5,[W15++]
15B4:  MOV     #C,W5
15B6:  REPEAT  #3
15B8:  MOV     [W5++],[W15++]
15BA:  CLR     W9
15BC:  MOV     #8000,W8
15BE:  BTSC.B  43.0
15C0:  XOR     W8,W3,W3
15C2:  CP0     W0
15C4:  BRA     NZ,15CC
15C6:  MOV     #7FFF,W10
15C8:  AND     W1,W10,W10
15CA:  BTSS.B  42.1
15CC:  MOV     W1,W10
15CE:  XOR     W3,W10,W11
15D0:  MOV     W1,W6
15D2:  MOV     W3,W7
15D4:  MOV     W3,W12
15D6:  BCLR.B  42.1
15D8:  BCLR.B  42.0
15DA:  RLC     W6,W6
15DC:  SWAP    W6
15DE:  AND     #FF,W6
15E0:  CP0     W6
15E2:  BRA     Z,1726
15E4:  BCLR.B  42.1
15E6:  BCLR.B  42.0
15E8:  RLC     W7,W7
15EA:  SWAP    W7
15EC:  AND     #FF,W7
15EE:  CP0     W7
15F0:  BRA     Z,1730
15F2:  BCLR.B  42.1
15F4:  BCLR.B  42.0
15F6:  CP      W7,W6
15F8:  BRA     Z,1732
15FA:  BRA     N,1742
15FC:  BCLR    W9.0
15FE:  BSET    W9.1
1600:  SUB     W7,W6,W8
1602:  MOV     W7,W6
1604:  AND     #FF,W1
1606:  BSET    W1.7
1608:  AND     #FF,W3
160A:  BSET    W3.7
160C:  MOV     #28,W7
160E:  CP      W7,W8
1610:  BRA     N,1634
1612:  BCLR.B  42.1
1614:  BCLR.B  42.0
1616:  RRC     W1,W1
1618:  RRC     W0,W0
161A:  DEC     W8,W8
161C:  BRA     NZ,1612
161E:  BRA     163A
1620:  MOV     #28,W7
1622:  CP      W7,W8
1624:  BRA     N,1638
1626:  BCLR.B  42.1
1628:  BCLR.B  42.0
162A:  RRC     W3,W3
162C:  RRC     W2,W2
162E:  DEC     W8,W8
1630:  BRA     NZ,1626
1632:  BRA     1652
1634:  MOV     W2,W0
1636:  MOV     W3,W1
1638:  BRA     16C0
163A:  BTSS    W11.F
163C:  BRA     1660
163E:  BTSC    W9.4
1640:  MOV     W12,W11
1642:  NEG     W0,W0
1644:  BRA     Z,164A
1646:  COM.B   W1L,W1L
1648:  BRA     164C
164A:  NEG     W1,W1
164C:  BTSC    W9.4
164E:  BRA     16A6
1650:  BRA     1660
1652:  BTSS    W11.F
1654:  BRA     1660
1656:  NEG     W2,W2
1658:  BRA     Z,165E
165A:  COM.B   W3L,W3L
165C:  BRA     1660
165E:  NEG     W3,W3
1660:  AND     #FF,W5
1662:  BCLR.B  42.1
1664:  BCLR.B  42.0
1666:  ADD     W0,W2,W0
1668:  ADDC.B  W1L,W3L,W1L
166A:  BTSC.B  42.0
166C:  BSET    W9.3
166E:  BTSC    W9.0
1670:  BRA     1684
1672:  BTSC    W9.1
1674:  BRA     1678
1676:  BRA     168E
1678:  BTSC    W11.F
167A:  BRA     16A6
167C:  BTSC    W9.3
167E:  BRA     16D2
1680:  BSET    W9.6
1682:  BRA     16C0
1684:  BTSC    W11.F
1686:  BRA     16A6
1688:  BTSC    W9.3
168A:  BRA     16D2
168C:  BRA     16C0
168E:  BCLR    W9.2
1690:  BTSC    W11.F
1692:  BRA     169C
1694:  MOV     W10,W11
1696:  BTSC    W9.3
1698:  BRA     16D2
169A:  BRA     1708
169C:  BSET    W9.4
169E:  XOR.B   #80,W1L
16A0:  BTSC    W1.7
16A2:  BRA     163E
16A4:  MOV     W10,W11
16A6:  AND     #FF,W1
16A8:  IOR      W0,  W1,W7
16AA:  BRA     Z,16C0
16AC:  BTSC    W1.7
16AE:  BRA     16C0
16B0:  BCLR.B  42.1
16B2:  BCLR.B  42.0
16B4:  RLC     W0,W0
16B6:  RLC     W1,W1
16B8:  DEC     W6,W6
16BA:  BTSC.B  42.1
16BC:  BRA     1720
16BE:  BRA     16AC
16C0:  BTSC    W9.0
16C2:  MOV     W10,W11
16C4:  BTSC    W9.1
16C6:  MOV     W12,W11
16C8:  BTSS    W9.5
16CA:  BRA     1700
16CC:  BTSC    W10.F
16CE:  BSET    W0.8
16D0:  BRA     1708
16D2:  BSET.B  42.0
16D4:  RRC.B   W1L,W1L
16D6:  RRC     W0,W0
16D8:  BTSC.B  42.0
16DA:  BSET    W9.5
16DC:  INC     W6,W6
16DE:  BRA     Z,1720
16E0:  BTSS    W9.5
16E2:  BRA     16F4
16E4:  INC     W0,W0
16E6:  BRA     NZ,16F4
16E8:  INC.B   W1L,W1L
16EA:  BRA     NZ,16F4
16EC:  RRC.B   W1L,W1L
16EE:  RRC     W0,W0
16F0:  INC     W6,W6
16F2:  BRA     Z,1720
16F4:  BTSC    W9.0
16F6:  MOV     W10,W11
16F8:  BTSC    W9.1
16FA:  MOV     W12,W11
16FC:  BTSC.B  42.1
16FE:  BRA     1720
1700:  BTSC    W9.6
1702:  MOV     W10,W11
1704:  BTSC    W9.7
1706:  MOV     W12,W11
1708:  IOR      W0,  W1,W2
170A:  BRA     Z,1752
170C:  BCLR    W1.7
170E:  SWAP    W6
1710:  BCLR.B  42.1
1712:  BCLR.B  42.0
1714:  RRC     W6,W6
1716:  XOR     W6,W1,W1
1718:  BSET    W1.F
171A:  BTSS    W11.F
171C:  BCLR    W1.F
171E:  BRA     1752
1720:  MOV     #0,W0
1722:  MOV     #0,W1
1724:  BRA     1752
1726:  BTSC    W10.F
1728:  XOR     W8,W3,W3
172A:  MOV     W2,W0
172C:  MOV     W3,W1
172E:  BRA     1752
1730:  BRA     1752
1732:  AND     #FF,W3
1734:  BSET    W3.7
1736:  AND     #FF,W1
1738:  BSET    W1.7
173A:  BTSC    W11.F
173C:  BCLR    W3.7
173E:  BSET    W9.2
1740:  BRA     1652
1742:  SUB     W6,W7,W8
1744:  AND     #FF,W1
1746:  BSET    W1.7
1748:  AND     #FF,W3
174A:  BSET    W3.7
174C:  BCLR    W9.1
174E:  BSET    W9.0
1750:  BRA     1620
1752:  MOV     #12,W5
1754:  REPEAT  #3
1756:  MOV     [--W15],[W5--]
1758:  MOV     [--W15],W5
175A:  RETURN  
175C:  MOV     W5,[W15++]
175E:  MOV     W6,[W15++]
1760:  MOV     W0,W4
1762:  MOV     W1,W5
1764:  CLR     W0
1766:  CLR     W1
1768:  BCLR    W6.0
176A:  BTSS    W5.F
176C:  BRA     177A
176E:  BSET    W6.0
1770:  NEG     W4,W4
1772:  BRA     Z,1778
1774:  COM     W5,W5
1776:  BRA     177A
1778:  NEG     W5,W5
177A:  IOR      W4,  W5,W3
177C:  BRA     Z,17A4
177E:  CLR     W2
1780:  MOV     #B6,W1
1782:  BTSC    W2.7
1784:  BRA     1794
1786:  BCLR.B  42.0
1788:  RLC     W4,W4
178A:  RLC     W5,W5
178C:  RLC     W0,W0
178E:  RLC     W2,W2
1790:  DEC     W1,W1
1792:  BRA     NZ,1782
1794:  SWAP    W1
1796:  BCLR.B  42.0
1798:  RRC     W1,W1
179A:  BCLR    W1.F
179C:  BCLR    W2.7
179E:  XOR.B   W2L,W1L,W1L
17A0:  BTSC    W6.0
17A2:  BSET    W1.F
17A4:  MOV     [--W15],W6
17A6:  MOV     [--W15],W5
17A8:  RETURN  
17AA:  MOV     W5,[W15++]
17AC:  MOV     #C,W5
17AE:  REPEAT  #4
17B0:  MOV     [W5++],[W15++]
17B2:  MOV     W0,W4
17B4:  MOV     W1,W5
17B6:  MOV     W3,W7
17B8:  MOV     W2,W6
17BA:  BCLR.B  42.0
17BC:  BCLR.B  42.1
17BE:  RLC     W1,W1
17C0:  SWAP    W1
17C2:  AND     #FF,W1
17C4:  CP0     W1
17C6:  BRA     Z,185E
17C8:  BCLR.B  42.0
17CA:  BCLR.B  42.1
17CC:  RLC     W3,W3
17CE:  SWAP    W3
17D0:  AND     #FF,W3
17D2:  CP0     W3
17D4:  BRA     Z,185E
17D6:  ZE      W0,W0
17D8:  ADD.B   W3L,W1L,W0L
17DA:  BRA     C,17E4
17DC:  SUB     #7F,W0
17DE:  BRA     Z,185E
17E0:  BRA     NC,185E
17E2:  BRA     17E8
17E4:  ADD.B   #81,W0L
17E6:  BRA     C,185E
17E8:  XOR     W5,W7,W10
17EA:  BCLR.B  42.0
17EC:  BCLR.B  42.1
17EE:  AND     #FF,W5
17F0:  BSET    W5.7
17F2:  BCLR.B  42.0
17F4:  AND     #FF,W7
17F6:  BSET    W7.7
17F8:  MUL.UU  W4,W6,W2
17FA:  MUL.UU  W5,W6,W8
17FC:  ADDC    W8,W3,W3
17FE:  MOV     W9,W1
1800:  BTSC.B  42.0
1802:  INC     W1,W1
1804:  BCLR.B  42.0
1806:  MUL.UU  W7,W4,W8
1808:  ADDC    W8,W3,W3
180A:  ADDC    W9,W1,W1
180C:  MUL.UU  W5,W7,W8
180E:  ADDC    W8,W1,W1
1810:  INC     W0,W0
1812:  CP0     W1
1814:  BTSC.B  42.1
1816:  BRA     181A
1818:  BRA     1820
181A:  CP0     W3
181C:  BTSC.B  42.1
181E:  BRA     182A
1820:  BTSC    W1.F
1822:  BRA     182A
1824:  RLC     W3,W3
1826:  RLC     W1,W1
1828:  DEC     W0,W0
182A:  MOV     W1,W2
182C:  BCLR.B  42.0
182E:  BTSS    W3.7
1830:  BRA     1844
1832:  MOV     #FF00,W7
1834:  AND     W3,W7,W3
1836:  ADD     #100,W3
1838:  ADDC    W2,#0,W2
183A:  CP0     W2
183C:  BRA     NZ,1844
183E:  CP0     W3
1840:  BRA     NZ,1844
1842:  INC     W0,W0
1844:  SWAP    W0
1846:  BCLR.B  42.0
1848:  BCLR.B  42.1
184A:  RRC     W0,W1
184C:  BTSC    W10.F
184E:  BSET    W1.F
1850:  BCLR    W2.F
1852:  SWAP    W2
1854:  XOR.B   W2L,W1L,W1L
1856:  SWAP    W3
1858:  MOV.B   W3L,W2L
185A:  MOV     W2,W0
185C:  BRA     1864
185E:  MOV     #0,W0
1860:  MOV     #0,W1
1862:  BRA     1864
1864:  MOV     #14,W5
1866:  REPEAT  #4
1868:  MOV     [--W15],[W5--]
186A:  MOV     [--W15],W5
186C:  RETURN  
186E:  MOV     W5,[W15++]
1870:  MOV     W1,W5
1872:  MOV     W0,W2
1874:  MOV     #B6,W4
1876:  RLC     W1,W1
1878:  SWAP    W1
187A:  AND     #FF,W1
187C:  SUB.B   W4L,W1L,W4L
187E:  MOV.B   W5L,W3L
1880:  BSET    W3.7
1882:  AND     #FF,W3
1884:  CLR     W0
1886:  CLR     W1
1888:  CP      W4,#1F
188A:  BRA     N,18AA
188C:  BCLR.B  42.0
188E:  RRC     W3,W3
1890:  RRC     W2,W2
1892:  RRC     W1,W1
1894:  RRC     W0,W0
1896:  DEC     W4,W4
1898:  BRA     NZ,188C
189A:  BTSS    W5.F
189C:  BRA     18AA
189E:  NEG     W0,W0
18A0:  BRA     Z,18A6
18A2:  COM     W1,W1
18A4:  BRA     18AA
18A6:  NEG     W1,W1
18A8:  BRA     18AA
18AA:  MOV     [--W15],W5
18AC:  RETURN  
....................  
.................... #list 
....................  
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 0 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B6 
.................... #pin_select INT2 = PIN_B5 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
....................  
.................... #pin_select OC1 = PIN_B0  // RP0  AX2 
.................... #pin_select OC2 = PIN_B1  // RP1  AX3 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "BL_support.h" 
.................... /******************************************************************************/ 
.................... /* File:    BL_Support.h													  */ 
.................... /* Author:  Dr.Santi Nuratch												  */ 
.................... /*          Embedded Computing and Control Lab., INC-KMUTT 				      */ 
.................... /* Created on 22 September 2016, 13:14										  */ 
.................... /******************************************************************************/ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... /****************************************************************************/ 
.................... // o/p pins   
.................... #define  INA_X  PIN_B4 //DI0 
.................... #define  INB_X  PIN_B5 //DI1 
.................... #define  INA_Y  PIN_B6 //DI2 
.................... #define  INB_Y  PIN_B7 //DI3 
....................  
.................... // i/p pins   
.................... #define  ENA_X  PIN_A2 //DO0 
.................... #define  ENB_X  PIN_A4 //DO1 
.................... #define  ENA_Y  PIN_B2 //DO2 
.................... #define  ENB_Y  PIN_B3 //DO3 
.................... #define  SW_X1  PIN_A0 //AX0 
.................... #define  SW_X2  PIN_B10  
.................... #define  SW_Y1  PIN_A1 //AX1 
.................... #define  SW_Y2  PIN_B11 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.H" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #define REPEAT_SAMPLING 3 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... typedef enum 
.................... { 
.................... 	STOP, 
.................... 	CCW, 
.................... 	CW 
.................... } ROTATION; 
....................  
.................... typedef struct PIDparameter 
.................... { 
....................  
.................... 	int32s u, e, delta_u, pu1, pe2, pe1; 
.................... 	float K_P,K_I,K_D; 
....................  
.................... }; 
....................  
.................... typedef struct EncoderParameter 
.................... { 
.................... 	int16u Old_A, New_Actual_A, Old_B, New_Actual_B; 
.................... 	int32u SamplingCounter_A, SamplingCounter_B; 
.................... 	int16u New_A[REPEAT_SAMPLING]; 
.................... 	int16u New_B[REPEAT_SAMPLING]; 
.................... 	int32u PulseCounterOld, PulseCounterNew,  
.................... 			PulseCounterInterval; 
.................... 	int32s PulseCounter; 
.................... }; 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #ifndef QuadEncoder_C_SRC 
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #define TMR_CLCK_FREQ 16000000 
.................... #define Pulse_Per_Rev 12*4*64 
.................... #define Distance_Per_Rev 78.5 //mm 
.................... #define K_P1 25 
.................... #define K_I1 0 
.................... #define K_D1 0 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... typedef enum 
.................... { 
.................... 	None, 
.................... 	X, 
.................... 	Y, 
.................... 	Z 
.................... } AXIS; 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                      PROTOTYPES OF LOCAL FUNCTIONS                     **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... void DisableIntr (void); 
.................... void EnableIntr (void); 
.................... static void HardwareInit (void); 
.................... static void GlobalVarInit (void); 
.................... void control_PID(AXIS Axis, int32u y, int32u r, float K_P, float K_I, float K_D); 
.................... void motor_drive(AXIS Axis, ROTATION Rotate, int32s u); 
.................... int16u Position_control(AXIS Axis, int32u target); 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED VARIABLES                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                            GLOBAL VARIABLES                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... static int32u SamplingCounterAX0, SamplingCounterAX1, SamplingCounterAX2, SamplingCounterAX3; 
.................... static int16u ReadPortA, ReadPortB; 
.................... static int16u AX0_Old, AX1_Old, AX2_Old, AX3_Old, AX0_New_Actual, AX1_New_Actual,  
.................... 				 AX2_New_Actual, AX3_New_Actual; 
.................... static int16u AX0_New[REPEAT_SAMPLING]; 
.................... static int16u AX1_New[REPEAT_SAMPLING]; 
.................... static int16u AX2_New[REPEAT_SAMPLING]; 
.................... static int16u AX3_New[REPEAT_SAMPLING]; 
.................... static ROTATION Rotate, RotateX, RotateY; 
.................... static AXIS Axis; 
.................... static int16u Tmr3IntrCounter = 0; 
.................... static int16u Sampling;  
.................... static int32s PulseCounterOld1, PulseCounterNew1, PulseCounterInterval1, 
.................... 				PulseCounter1; 
.................... static int32s PulseCounterOld2, PulseCounterNew2, PulseCounterInterval2, 
.................... 				PulseCounter2; 
.................... static int32s u_X, e_X, delta_u_X, pu1_X, pe2_X, pe1_X, 
.................... 				u_Y, e_Y, delta_u_Y, pu1_Y, pe2_Y, pe1_Y; 
.................... static int32u r; //desire position 
.................... static int16u duty_X, duty_Y; 
.................... static int8u state=0; 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED FUNCTIONS                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             LOCAL FUNCTIONS                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... void main(void) 
*
1C92:  MOV     #2780,W15
1C94:  MOV     #27FF,W0
1C96:  MOV     W0,20
1C98:  NOP     
1C9A:  MOV     #4444,W0
1C9C:  MOV     W0,B0
1C9E:  BSET.B  81.7
1CA0:  MOV     #46,W0
1CA2:  MOV.B   W0L,742
1CA4:  MOV     #57,W0
1CA6:  MOV.B   W0L,742
1CA8:  BCLR.B  742.6
1CAA:  MOV     #3F0C,W0
1CAC:  MOV     W0,6A4
1CAE:  MOV     #1312,W0
1CB0:  MOV     W0,6C0
1CB2:  MOV     #300,W0
1CB4:  MOV     W0,6CC
1CB6:  MOV     #46,W0
1CB8:  MOV.B   W0L,742
1CBA:  MOV     #57,W0
1CBC:  MOV.B   W0L,742
1CBE:  BSET.B  742.6
1CC0:  CLR     744
1CC2:  MOV     #8000,W4
1CC4:  MOV     W4,220
1CC6:  MOV     #400,W4
1CC8:  MOV     W4,222
1CCA:  BSET.B  220.3
1CCC:  MOV     #22,W4
1CCE:  MOV     W4,228
1CD0:  CLR     848
1CD2:  CLR.B   8A4
1CD4:  SETM    32C
1CD6:  MOV     #906,W4
1CD8:  MOV     W4,806
1CDA:  MOV     #1E76,W4
1CDC:  MOV     W4,906
1CDE:  CLR     908
1CE0:  BRA     1D0A
1CE2:  DATA    80,02,08
1CE4:  DATA    00,00,00
1CE6:  DATA    C0,40,08
1CE8:  DATA    08,00,C0
1CEA:  DATA    5A,08,4A
1CEC:  DATA    00,00,00
1CEE:  INC     W2,W2
1CF0:  CP      W2,#1
1CF2:  BRA     NZ,1CFC
1CF4:  TBLRDL  [W1],W3
1CF6:  TBLRDH  [W1++],W4
1CF8:  MOV.B   6,W0L
1CFA:  RETURN  
1CFC:  CP      W2,#2
1CFE:  BRA     NZ,1D04
1D00:  MOV.B   7,W0L
1D02:  RETURN  
1D04:  MOV.B   8,W0L
1D06:  CLR     W2
1D08:  RETURN  
1D0A:  MOV     #0,W6
1D0C:  MOV     #0,W0
1D0E:  MOV     W0,32
1D10:  MOV     #1CE2,W0
1D12:  MOV     W0,W1
1D14:  CLR     W2
1D16:  CALL    1CEE
1D1A:  MOV.B   W0L,B
1D1C:  CALL    1CEE
1D20:  MOV.B   W0L,A
1D22:  CP0     W5
1D24:  BRA     Z,1D58
1D26:  BTSS    W5.F
1D28:  BRA     1D38
1D2A:  CALL    1CEE
1D2E:  MOV.B   W0L,D
1D30:  CALL    1CEE
1D34:  MOV.B   W0L,C
1D36:  BCLR    W5.F
1D38:  BTSS    W5.E
1D3A:  BRA     1D4C
1D3C:  BCLR    W5.E
1D3E:  DEC     W5,W5
1D40:  CALL    1CEE
1D44:  MOV.B   W0L,W7L
1D46:  REPEAT  W5
1D48:  MOV.B   W7L,[W6++]
1D4A:  BRA     1D16
1D4C:  CALL    1CEE
1D50:  MOV.B   W0L,[W6++]
1D52:  DEC     W5,W5
1D54:  BRA     NZ,1D4C
1D56:  BRA     1D16
.................... { 
.................... 	DisableIntr(); 
1D58:  CALL    12C6
.................... 	GlobalVarInit(); 
1D5C:  CALL    12D0
.................... 	HardwareInit(); 
1D60:  CALL    1318
.................... 	EnableIntr(); 
1D64:  CALL    13B8
.................... 	int32u c = 1, d = 1; 
1D68:  MOV     #1,W4
1D6A:  MOV     W4,8A6
1D6C:  CLR     8A8
1D6E:  MOV     #1,W4
1D70:  MOV     W4,8AA
1D72:  CLR     8AC
.................... 	for(;;) 
.................... 	{ 
.................... 		/*if(Tmr3IntrCounter != 0) 
.................... 		{ 
.................... 			Tmr3IntrCounter--; 
.................... 			if (Sampling == 1) 
.................... 			{ 
.................... 				Sampling = 0; 
....................  
.................... 			} 
.................... 		}*/ 
....................  
.................... 	/*	motor_drive(X, CW, 500); 
....................    		motor_drive(Y, CW, 500); 
....................    		for ( c = 1 ; c <= 500000 ; c++ ) 
.................... 		{} 
.................... 		motor_drive(X, CCW, 500); 
.................... 		motor_drive(Y, CCW, 500); 
....................    		for ( c = 1 ; c <= 500000 ; c++ ) 
.................... 		{} 
.................... 		printf("X: %d , Y: %d \r\n",PulseCounter1,PulseCounter2); 
.................... 	*/ 
.................... 		switch(state) 
1D74:  MOV.B   8A4,W0L
1D76:  CLR.B   1
1D78:  XOR     #0,W0
1D7A:  BRA     Z,1D82
1D7C:  XOR     #1,W0
1D7E:  BRA     Z,1D92
1D80:  BRA     1DA0
.................... 		{ 
.................... 			case 0: Position_control(X,100); break;//Position_control(Y,100); break; 
1D82:  MOV.B   #1,W0L
1D84:  MOV.B   W0L,8B0
1D86:  MOV     #64,W4
1D88:  MOV     W4,8B2
1D8A:  CLR     8B4
1D8C:  CALL    1BE2
1D90:  BRA     1DA0
.................... 			case 1: Position_control(X,0); break;//Position_control(Y,100); break; 
1D92:  MOV.B   #1,W0L
1D94:  MOV.B   W0L,8B0
1D96:  CLR     8B2
1D98:  CLR     8B4
1D9A:  CALL    1BE2
1D9E:  BRA     1DA0
.................... 			//case 2: Position_control(X,50); Position_control(Y,0); break; 
.................... 			//case 3: Position_control(X,0); Position_control(Y,0); break; 
.................... 		}		 
.................... 		if(abs(e_X)<5 && abs(e_Y)<5 )	{state++; state%=2;} 
1DA0:  MOV     870,W0
1DA2:  MOV     872,W1
1DA4:  BTSS    W1.F
1DA6:  BRA     1DB4
1DA8:  MOV     #0,W4
1DAA:  MOV     870,W3
1DAC:  SUB     W4,W3,W0
1DAE:  MOV     #0,W4
1DB0:  MOV     872,W3
1DB2:  SUBB    W4,W3,W1
1DB4:  MOV     W0,W5
1DB6:  MOV     W1,W6
1DB8:  CP      W6,#0
1DBA:  BRA     GT,1DEC
1DBC:  BRA     LT,1DC2
1DBE:  CP      W5,#5
1DC0:  BRA     C,1DEC
1DC2:  MOV     888,W0
1DC4:  MOV     88A,W1
1DC6:  BTSS    W1.F
1DC8:  BRA     1DD6
1DCA:  MOV     #0,W4
1DCC:  MOV     888,W3
1DCE:  SUB     W4,W3,W0
1DD0:  MOV     #0,W4
1DD2:  MOV     88A,W3
1DD4:  SUBB    W4,W3,W1
1DD6:  MOV     W0,W5
1DD8:  MOV     W1,W6
1DDA:  CP      W6,#0
1DDC:  BRA     GT,1DEC
1DDE:  BRA     LT,1DE4
1DE0:  CP      W5,#5
1DE2:  BRA     C,1DEC
1DE4:  INC.B   08A4
1DE6:  MOV.B   8A4,W0L
1DE8:  AND.B   W0L,#1,W0L
1DEA:  MOV.B   W0L,8A4
1DEC:  BRA     1D74
.................... 	} 
.................... } 
....................  
1DEE:  PWRSAV  #0
.................... int16u Position_control(AXIS Axis, int32u target ) //target (mm) 
*
1BE2:  MOV     W5,[W15++]
1BE4:  MOV     W6,[W15++]
1BE6:  MOV     W7,[W15++]
.................... {	 
.................... 	int32s PulseCounter; 
.................... 	r = target*Pulse_Per_Rev/Distance_Per_Rev; 
1BE8:  MOV     8B2,W0
1BEA:  MOV     8B4,W1
1BEC:  MOV     #C,W2
1BEE:  MOV     #0,W3
1BF0:  CALL    13C0
1BF4:  MOV     W0,W5
1BF6:  MOV     W1,W6
1BF8:  MOV     #2,W4
1BFA:  CLR.B   9
1BFC:  INC     W4,W4
1BFE:  DEC     W4,W4
1C00:  BRA     Z,1C08
1C02:  SL      W5,W5
1C04:  RLC     W6,W6
1C06:  BRA     1BFE
1C08:  MOV     #6,W4
1C0A:  CLR.B   9
1C0C:  INC     W4,W4
1C0E:  DEC     W4,W4
1C10:  BRA     Z,1C18
1C12:  SL      W5,W5
1C14:  RLC     W6,W6
1C16:  BRA     1C0E
1C18:  MOV     W5,W0
1C1A:  MOV     W6,W1
1C1C:  MOV     #0,W2
1C1E:  MOV     #0,W3
1C20:  CALL    13F0
1C24:  MOV     W5,[W15++]
1C26:  MOV     W6,[W15++]
1C28:  MOV     #0,W4
1C2A:  MOV     #0,W5
1C2C:  MOV     #A000,W6
1C2E:  MOV     #4053,W7
1C30:  CALL    1454
1C34:  MOV     [--W15],W6
1C36:  MOV     [--W15],W5
1C38:  CALL    155C
1C3C:  MOV     W0,89C
1C3E:  MOV     W1,89E
.................... 	switch(Axis){ 
1C40:  MOV.B   8B0,W0L
1C42:  CLR.B   1
1C44:  XOR     #1,W0
1C46:  BRA     Z,1C4E
1C48:  XOR     #3,W0
1C4A:  BRA     Z,1C58
1C4C:  BRA     1C62
.................... 		case X: 
.................... 			PulseCounter = PulseCounter1; 
1C4E:  PUSH    858
1C50:  POP     8B6
1C52:  PUSH    85A
1C54:  POP     8B8
.................... 			break; 
1C56:  BRA     1C62
.................... 		case Y: 
.................... 			PulseCounter = PulseCounter2 ; 
1C58:  PUSH    868
1C5A:  POP     8B6
1C5C:  PUSH    86A
1C5E:  POP     8B8
.................... 			break; 
1C60:  BRA     1C62
.................... 	} 
.................... 	control_PID(Axis, PulseCounter, r, K_P1, K_I1, K_D1); 
1C62:  MOV.B   8B0,W0L
1C64:  MOV.B   W0L,8C0
1C66:  PUSH    8B6
1C68:  POP     8C2
1C6A:  PUSH    8B8
1C6C:  POP     8C4
1C6E:  PUSH    89C
1C70:  POP     8C6
1C72:  PUSH    89E
1C74:  POP     8C8
1C76:  CLR     8CA
1C78:  MOV     #41C8,W4
1C7A:  MOV     W4,8CC
1C7C:  CLR     8CE
1C7E:  CLR     8D0
1C80:  CLR     8D2
1C82:  CLR     8D4
1C84:  CALL    1956
.................... 	return 0; 
1C88:  CLR     0
1C8A:  MOV     [--W15],W7
1C8C:  MOV     [--W15],W6
1C8E:  MOV     [--W15],W5
1C90:  RETURN  
.................... } 
....................  
.................... void control_PID(AXIS Axis, int32u y, int32u r, float K_P, float K_I, float K_D) 
*
1956:  MOV     W5,[W15++]
1958:  MOV     W6,[W15++]
195A:  MOV     W7,[W15++]
195C:  MOV     W8,[W15++]
.................... { 
.................... 	switch(Axis){ 
195E:  MOV.B   8C0,W0L
1960:  CLR.B   1
1962:  XOR     #1,W0
1964:  BRA     Z,196C
1966:  XOR     #3,W0
1968:  BRA     Z,1AA2
196A:  BRA     1BD8
.................... 		case X: 
.................... 			e_X = r-y; 
196C:  MOV     8C6,W4
196E:  MOV     8C2,W3
1970:  SUB     W4,W3,W0
1972:  MOV     W0,870
1974:  MOV     8C8,W4
1976:  MOV     8C4,W3
1978:  SUBB    W4,W3,W0
197A:  MOV     W0,872
.................... 			delta_u_X = (K_P+K_I+K_D)*e_X-(K_P+2*K_D)*pe1_X+(K_D)*pe2_X; 
197C:  BCLR.B  43.0
197E:  MOV     8CA,W0
1980:  MOV     8CC,W1
1982:  MOV     8CE,W2
1984:  MOV     8D0,W3
1986:  CALL    15B2
198A:  MOV     W0,W5
198C:  MOV     W1,W6
198E:  BCLR.B  43.0
1990:  MOV     W5,W0
1992:  MOV     W6,W1
1994:  MOV     8D2,W2
1996:  MOV     8D4,W3
1998:  CALL    15B2
199C:  MOV     W0,W5
199E:  MOV     W1,W6
19A0:  MOV     870,W0
19A2:  MOV     872,W1
19A4:  CALL    175C
19A8:  MOV     W0,W2
19AA:  MOV     W1,W3
19AC:  MOV     W5,W0
19AE:  MOV     W6,W1
19B0:  CALL    17AA
19B4:  MOV     W0,W5
19B6:  MOV     W1,W6
19B8:  MOV     #0,W0
19BA:  MOV     #4000,W1
19BC:  MOV     8D2,W2
19BE:  MOV     8D4,W3
19C0:  CALL    17AA
19C4:  BCLR.B  43.0
19C6:  MOV     W0,W2
19C8:  MOV     W1,W3
19CA:  MOV     8CA,W0
19CC:  MOV     8CC,W1
19CE:  CALL    15B2
19D2:  MOV     W0,W7
19D4:  MOV     W1,W8
19D6:  MOV     880,W0
19D8:  MOV     882,W1
19DA:  CALL    175C
19DE:  MOV     W0,W2
19E0:  MOV     W1,W3
19E2:  MOV     W7,W0
19E4:  MOV     W8,W1
19E6:  CALL    17AA
19EA:  BSET.B  43.0
19EC:  MOV     W0,W2
19EE:  MOV     W1,W3
19F0:  MOV     W5,W0
19F2:  MOV     W6,W1
19F4:  CALL    15B2
19F8:  MOV     W0,W5
19FA:  MOV     W1,W6
19FC:  MOV     87C,W0
19FE:  MOV     87E,W1
1A00:  CALL    175C
1A04:  MOV     W0,W2
1A06:  MOV     W1,W3
1A08:  MOV     8D2,W0
1A0A:  MOV     8D4,W1
1A0C:  CALL    17AA
1A10:  BCLR.B  43.0
1A12:  MOV     W0,W2
1A14:  MOV     W1,W3
1A16:  MOV     W5,W0
1A18:  MOV     W6,W1
1A1A:  CALL    15B2
1A1E:  CALL    186E
1A22:  MOV     W0,874
1A24:  MOV     W1,876
.................... 			u_X = pu1_X+delta_u_X; 
1A26:  MOV     878,W0
1A28:  ADD     874,W0
1A2A:  MOV     W0,86C
1A2C:  MOV     876,W4
1A2E:  MOV     87A,W3
1A30:  ADDC    W3,W4,W0
1A32:  MOV     W0,86E
.................... 		 
.................... 			if ( u_X >= 0 ) motor_drive(Axis, CW, u_X); 
1A34:  MOV     86E,W4
1A36:  CP      W4,#0
1A38:  BRA     LT,1A58
1A3A:  BRA     GT,1A42
1A3C:  MOV     86C,W4
1A3E:  CP      W4,#0
1A40:  BRA     NC,1A58
1A42:  MOV.B   8C0,W0L
1A44:  MOV.B   W0L,8F0
1A46:  MOV.B   #2,W0L
1A48:  MOV.B   W0L,8F1
1A4A:  PUSH    86C
1A4C:  POP     8F2
1A4E:  PUSH    86E
1A50:  POP     8F4
1A52:  CALL    18AE
1A56:  BRA     1A88
.................... 			else 			motor_drive(Axis, CCW, abs(u_X)); 
1A58:  MOV     86C,W0
1A5A:  MOV     86E,W1
1A5C:  BTSS    W1.F
1A5E:  BRA     1A6C
1A60:  MOV     #0,W4
1A62:  MOV     86C,W3
1A64:  SUB     W4,W3,W0
1A66:  MOV     #0,W4
1A68:  MOV     86E,W3
1A6A:  SUBB    W4,W3,W1
1A6C:  MOV     W0,W5
1A6E:  MOV     W1,W6
1A70:  MOV     W0,[W15++]
1A72:  MOV.B   8C0,W0L
1A74:  MOV.B   W0L,8F0
1A76:  MOV     [--W15],W0
1A78:  MOV     W0,[W15++]
1A7A:  MOV.B   #1,W0L
1A7C:  MOV.B   W0L,8F1
1A7E:  MOV     [--W15],W0
1A80:  MOV     W5,8F2
1A82:  MOV     W6,8F4
1A84:  CALL    18AE
.................... 			pu1_X = u_X; 
1A88:  PUSH    86C
1A8A:  POP     878
1A8C:  PUSH    86E
1A8E:  POP     87A
.................... 			pe2_X = pe1_X; 
1A90:  PUSH    880
1A92:  POP     87C
1A94:  PUSH    882
1A96:  POP     87E
.................... 			pe1_X = e_X;			 
1A98:  PUSH    870
1A9A:  POP     880
1A9C:  PUSH    872
1A9E:  POP     882
.................... 			break; 
1AA0:  BRA     1BD8
.................... 		case Y: 
.................... 			e_Y = r-y; 
1AA2:  MOV     8C6,W4
1AA4:  MOV     8C2,W3
1AA6:  SUB     W4,W3,W0
1AA8:  MOV     W0,888
1AAA:  MOV     8C8,W4
1AAC:  MOV     8C4,W3
1AAE:  SUBB    W4,W3,W0
1AB0:  MOV     W0,88A
.................... 			delta_u_Y = (K_P+K_I+K_D)*e_Y-(K_P+2*K_D)*pe1_Y+(K_D)*pe2_Y; 
1AB2:  BCLR.B  43.0
1AB4:  MOV     8CA,W0
1AB6:  MOV     8CC,W1
1AB8:  MOV     8CE,W2
1ABA:  MOV     8D0,W3
1ABC:  CALL    15B2
1AC0:  MOV     W0,W5
1AC2:  MOV     W1,W6
1AC4:  BCLR.B  43.0
1AC6:  MOV     W5,W0
1AC8:  MOV     W6,W1
1ACA:  MOV     8D2,W2
1ACC:  MOV     8D4,W3
1ACE:  CALL    15B2
1AD2:  MOV     W0,W5
1AD4:  MOV     W1,W6
1AD6:  MOV     888,W0
1AD8:  MOV     88A,W1
1ADA:  CALL    175C
1ADE:  MOV     W0,W2
1AE0:  MOV     W1,W3
1AE2:  MOV     W5,W0
1AE4:  MOV     W6,W1
1AE6:  CALL    17AA
1AEA:  MOV     W0,W5
1AEC:  MOV     W1,W6
1AEE:  MOV     #0,W0
1AF0:  MOV     #4000,W1
1AF2:  MOV     8D2,W2
1AF4:  MOV     8D4,W3
1AF6:  CALL    17AA
1AFA:  BCLR.B  43.0
1AFC:  MOV     W0,W2
1AFE:  MOV     W1,W3
1B00:  MOV     8CA,W0
1B02:  MOV     8CC,W1
1B04:  CALL    15B2
1B08:  MOV     W0,W7
1B0A:  MOV     W1,W8
1B0C:  MOV     898,W0
1B0E:  MOV     89A,W1
1B10:  CALL    175C
1B14:  MOV     W0,W2
1B16:  MOV     W1,W3
1B18:  MOV     W7,W0
1B1A:  MOV     W8,W1
1B1C:  CALL    17AA
1B20:  BSET.B  43.0
1B22:  MOV     W0,W2
1B24:  MOV     W1,W3
1B26:  MOV     W5,W0
1B28:  MOV     W6,W1
1B2A:  CALL    15B2
1B2E:  MOV     W0,W5
1B30:  MOV     W1,W6
1B32:  MOV     894,W0
1B34:  MOV     896,W1
1B36:  CALL    175C
1B3A:  MOV     W0,W2
1B3C:  MOV     W1,W3
1B3E:  MOV     8D2,W0
1B40:  MOV     8D4,W1
1B42:  CALL    17AA
1B46:  BCLR.B  43.0
1B48:  MOV     W0,W2
1B4A:  MOV     W1,W3
1B4C:  MOV     W5,W0
1B4E:  MOV     W6,W1
1B50:  CALL    15B2
1B54:  CALL    186E
1B58:  MOV     W0,88C
1B5A:  MOV     W1,88E
.................... 			u_Y = pu1_Y+delta_u_Y; 
1B5C:  MOV     890,W0
1B5E:  ADD     88C,W0
1B60:  MOV     W0,884
1B62:  MOV     88E,W4
1B64:  MOV     892,W3
1B66:  ADDC    W3,W4,W0
1B68:  MOV     W0,886
.................... 		 
.................... 			if ( u_Y >= 0 ) motor_drive(Axis, CW, u_Y); 
1B6A:  MOV     886,W4
1B6C:  CP      W4,#0
1B6E:  BRA     LT,1B8E
1B70:  BRA     GT,1B78
1B72:  MOV     884,W4
1B74:  CP      W4,#0
1B76:  BRA     NC,1B8E
1B78:  MOV.B   8C0,W0L
1B7A:  MOV.B   W0L,8F0
1B7C:  MOV.B   #2,W0L
1B7E:  MOV.B   W0L,8F1
1B80:  PUSH    884
1B82:  POP     8F2
1B84:  PUSH    886
1B86:  POP     8F4
1B88:  CALL    18AE
1B8C:  BRA     1BBE
.................... 			else 			motor_drive(Axis, CCW, abs(u_Y)); 
1B8E:  MOV     884,W0
1B90:  MOV     886,W1
1B92:  BTSS    W1.F
1B94:  BRA     1BA2
1B96:  MOV     #0,W4
1B98:  MOV     884,W3
1B9A:  SUB     W4,W3,W0
1B9C:  MOV     #0,W4
1B9E:  MOV     886,W3
1BA0:  SUBB    W4,W3,W1
1BA2:  MOV     W0,W5
1BA4:  MOV     W1,W6
1BA6:  MOV     W0,[W15++]
1BA8:  MOV.B   8C0,W0L
1BAA:  MOV.B   W0L,8F0
1BAC:  MOV     [--W15],W0
1BAE:  MOV     W0,[W15++]
1BB0:  MOV.B   #1,W0L
1BB2:  MOV.B   W0L,8F1
1BB4:  MOV     [--W15],W0
1BB6:  MOV     W5,8F2
1BB8:  MOV     W6,8F4
1BBA:  CALL    18AE
.................... 			pu1_X = u_Y; 
1BBE:  PUSH    884
1BC0:  POP     878
1BC2:  PUSH    886
1BC4:  POP     87A
.................... 			pe2_X = pe1_Y; 
1BC6:  PUSH    898
1BC8:  POP     87C
1BCA:  PUSH    89A
1BCC:  POP     87E
.................... 			pe1_X = e_Y; 
1BCE:  PUSH    888
1BD0:  POP     880
1BD2:  PUSH    88A
1BD4:  POP     882
.................... 			break; 
1BD6:  BRA     1BD8
.................... 	} 
1BD8:  MOV     [--W15],W8
1BDA:  MOV     [--W15],W7
1BDC:  MOV     [--W15],W6
1BDE:  MOV     [--W15],W5
1BE0:  RETURN  
....................  
.................... } 
.................... 			 
.................... void motor_drive(AXIS Axis, ROTATION Rotate, int32s u) 
.................... { 
.................... 	if( u < 0) 		u=0; 
*
18AE:  MOV     8F4,W4
18B0:  CP      W4,#0
18B2:  BRA     GT,18C0
18B4:  BRA     LT,18BC
18B6:  MOV     8F2,W4
18B8:  CP      W4,#0
18BA:  BRA     C,18C0
18BC:  CLR     8F2
18BE:  CLR     8F4
.................... 	if( u > 1000 )  u=1000; 
18C0:  MOV     8F4,W4
18C2:  CP      W4,#0
18C4:  BRA     LT,18D6
18C6:  BRA     GT,18D0
18C8:  MOV     8F2,W4
18CA:  MOV     #3E8,W3
18CC:  CP      W3,W4
18CE:  BRA     C,18D6
18D0:  MOV     #3E8,W4
18D2:  MOV     W4,8F2
18D4:  CLR     8F4
.................... 	switch(Axis){  
18D6:  MOV.B   8F0,W0L
18D8:  CLR.B   1
18DA:  XOR     #1,W0
18DC:  BRA     Z,18E8
18DE:  XOR     #3,W0
18E0:  BRA     Z,1914
18E2:  XOR     #1,W0
18E4:  BRA     Z,1940
18E6:  BRA     1954
.................... 		case X:  
.................... 			duty_X = u; 
18E8:  PUSH    8F2
18EA:  POP     8A0
.................... 			switch(Rotate){  
18EC:  MOV.B   8F1,W0L
18EE:  CLR.B   1
18F0:  XOR     #1,W0
18F2:  BRA     Z,18FE
18F4:  XOR     #3,W0
18F6:  BRA     Z,1904
18F8:  XOR     #2,W0
18FA:  BRA     Z,190A
18FC:  BRA     190E
.................... 				case CCW:  
.................... 					output_high(INA_X); 
18FE:  BSET.B  2CC.4
.................... 					output_low(INB_X); 
1900:  BCLR.B  2CC.5
.................... 					break;  
1902:  BRA     190E
.................... 				case CW:  
.................... 					output_low(INA_X); 
1904:  BCLR.B  2CC.4
.................... 					output_high(INB_X); 
1906:  BSET.B  2CC.5
.................... 					break;  
1908:  BRA     190E
.................... 				case STOP: 
.................... 					duty_X = 0; 
190A:  CLR     8A0
.................... 					break; 
190C:  BRA     190E
.................... 			} 
.................... 			set_pwm_duty(1, duty_X);			 
190E:  PUSH    8A0
1910:  POP     180
.................... 			break; 
1912:  BRA     1954
.................... 		case Y: 
.................... 			duty_Y = u; 
1914:  PUSH    8F2
1916:  POP     8A2
.................... 			switch(Rotate){				 
1918:  MOV.B   8F1,W0L
191A:  CLR.B   1
191C:  XOR     #1,W0
191E:  BRA     Z,192A
1920:  XOR     #3,W0
1922:  BRA     Z,1930
1924:  XOR     #2,W0
1926:  BRA     Z,1936
1928:  BRA     193A
.................... 				case CCW: 
.................... 					output_high(INA_Y); 
192A:  BSET.B  2CC.6
.................... 					output_low(INB_Y); 
192C:  BCLR.B  2CC.7
.................... 					break; 
192E:  BRA     193A
.................... 				case CW: 
.................... 					output_low(INA_Y); 
1930:  BCLR.B  2CC.6
.................... 					output_high(INB_Y); 
1932:  BSET.B  2CC.7
.................... 					break; 
1934:  BRA     193A
.................... 				case STOP: 
.................... 					duty_Y = 0; 
1936:  CLR     8A2
.................... 					break; 
1938:  BRA     193A
.................... 			} 
.................... 			set_pwm_duty(2, duty_Y); 
193A:  PUSH    8A2
193C:  POP     186
.................... 			break; 
193E:  BRA     1954
.................... 		case Z: 
.................... 			switch(Rotate){ 
1940:  MOV.B   8F1,W0L
1942:  CLR.B   1
1944:  XOR     #1,W0
1946:  BRA     Z,194E
1948:  XOR     #3,W0
194A:  BRA     Z,1950
194C:  BRA     1952
.................... 				case CCW: 
.................... 					break; 
194E:  BRA     1952
.................... 				case CW: 
.................... 					break; 
1950:  BRA     1952
.................... 			} 
.................... 			break; 
1952:  BRA     1954
.................... 	} 
1954:  RETURN  
.................... } 
....................  
.................... void DisableIntr(void) 
.................... { 
.................... 	disable_interrupts(INTR_GLOBAL); 
*
12C6:  BCLR.B  81.7
12C8:  MOV     #E0,W4
12CA:  MOV     W4,42
12CC:  BSET.B  81.7
12CE:  RETURN  
.................... }			 
....................  
.................... void EnableIntr(void) 
.................... { 
.................... 	enable_interrupts(INTR_GLOBAL); 
*
13B8:  BCLR.B  81.7
13BA:  CLR     42
13BC:  BSET.B  81.7
13BE:  RETURN  
.................... } 
....................  
.................... static void GlobalVarInit(void) 
.................... { 
.................... 	//interface 
.................... 	Sampling = 0; 
*
12D0:  CLR     84A
.................... 	Tmr3IntrCounter = 0; 
12D2:  CLR     848
.................... 	//encoder 
.................... 	SamplingCounterAX0 = 0; 
12D4:  CLR     808
12D6:  CLR     80A
.................... 	SamplingCounterAX1 = 0; 
12D8:  CLR     80C
12DA:  CLR     80E
.................... 	SamplingCounterAX2 = 0; 
12DC:  CLR     810
12DE:  CLR     812
.................... 	SamplingCounterAX3 = 0; 
12E0:  CLR     814
12E2:  CLR     816
.................... 	RotateX = STOP; 
12E4:  CLR.B   845
.................... 	RotateY = STOP; 
12E6:  CLR.B   846
.................... 	PulseCounter1 = 0; 
12E8:  CLR     858
12EA:  CLR     85A
.................... 	PulseCounterOld1 = 0; 
12EC:  CLR     84C
12EE:  CLR     84E
.................... 	PulseCounter2 = 0; 
12F0:  CLR     868
12F2:  CLR     86A
.................... 	PulseCounterOld2 = 0; 
12F4:  CLR     85C
12F6:  CLR     85E
.................... 	//PID 
.................... 	Axis = None; 
12F8:  CLR.B   847
.................... 	pu1_X = 0; 
12FA:  CLR     878
12FC:  CLR     87A
.................... 	pe1_X = 0; 
12FE:  CLR     880
1300:  CLR     882
.................... 	pe2_X = 0; 
1302:  CLR     87C
1304:  CLR     87E
.................... 	pu1_Y = 0; 
1306:  CLR     890
1308:  CLR     892
.................... 	pe1_Y = 0; 
130A:  CLR     898
130C:  CLR     89A
.................... 	pe2_Y = 0; 
130E:  CLR     894
1310:  CLR     896
.................... 	//motor drive 
.................... 	duty_X = 0; 
1312:  CLR     8A0
.................... 	duty_Y = 0; 
1314:  CLR     8A2
.................... 	return; 
1316:  RETURN  
.................... } 
....................  
.................... static void HardwareInit(void) 
1318:  MOV     W5,[W15++]
.................... { 
.................... 	setup_adc_ports(NO_ANALOGS); 
131A:  SETM    32C
.................... 	set_tris_a(get_tris_a() & 0xff17); // 1111 1111 0010 0011 
131C:  MOV     2C0,W5
131E:  MOV     #FF17,W0
1320:  AND     W0,W5,W5
1322:  MOV     W5,2C0
.................... 	set_tris_b(get_tris_b() & 0xff0f); // 1111 1111 0000 1111 
1324:  MOV     2C8,W5
1326:  MOV     #FF0F,W0
1328:  AND     W0,W5,W5
132A:  MOV     W5,2C8
.................... 	ReadPortA = input_a() & 0x0014; 
132C:  MOV     2C2,W5
132E:  AND     W5,#14,W0
1330:  MOV     W0,818
.................... 	ReadPortB = input_b() & 0x000C; 
1332:  MOV     2CA,W5
1334:  AND     W5,#C,W0
1336:  MOV     W0,81A
.................... 	AX0_Old = (ReadPortA & 0x0004) >> 2; 
1338:  MOV     818,W0
133A:  AND     W0,#4,W5
133C:  MOV     W5,81C
133E:  LSR     81C
1340:  LSR     81C
.................... 	AX1_Old = (ReadPortA & 0x0010) >> 4; 
1342:  MOV     818,W0
1344:  AND     W0,#10,W5
1346:  LSR     W5,#4,W0
1348:  MOV     W0,81E
.................... 	AX2_Old = (ReadPortB & 0x0004) >> 2; 
134A:  MOV     81A,W0
134C:  AND     W0,#4,W5
134E:  MOV     W5,820
1350:  LSR     820
1352:  LSR     820
.................... 	AX3_Old = (ReadPortB & 0x0008) >> 3; 
1354:  MOV     81A,W0
1356:  AND     W0,#8,W5
1358:  MOV     W5,822
135A:  LSR     822
135C:  LSR     822
135E:  LSR     822
.................... 	//Timer4 
.................... 	set_timer4(0); 
1360:  CLR     114
.................... 	setup_timer4(TMR_INTERNAL | TMR_DIV_BY_1, 499); //sampling xxx us for X 
1362:  CLR     11E
1364:  MOV     #1F3,W4
1366:  MOV     W4,11A
1368:  MOV     #8000,W4
136A:  MOV     W4,11E
.................... 	clear_interrupt(INT_TIMER4); 
136C:  BCLR.B  87.3
.................... 	enable_interrupts(INT_TIMER4); 
136E:  BSET.B  97.3
.................... 	//Timer5 
.................... 	set_timer5(0); 
1370:  CLR     118
.................... 	setup_timer5(TMR_INTERNAL | TMR_DIV_BY_1, 499); //sampling xxx us for Y 
1372:  CLR     120
1374:  MOV     #1F3,W4
1376:  MOV     W4,11C
1378:  MOV     #8000,W4
137A:  MOV     W4,120
.................... 	clear_interrupt(INT_TIMER5); 
137C:  BCLR.B  87.4
.................... 	enable_interrupts(INT_TIMER5); 
137E:  BSET.B  97.4
.................... 	//Timer3 
.................... 	set_timer3(0); 
1380:  CLR     10A
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_256, 31249); //0.5 sec 
1382:  CLR     112
1384:  MOV     #7A11,W4
1386:  MOV     W4,10E
1388:  MOV     #8030,W4
138A:  MOV     W4,112
.................... 	clear_interrupt(INT_TIMER3); 
138C:  BCLR.B  85.0
.................... 	enable_interrupts(INT_TIMER3);	 
138E:  BSET.B  95.0
.................... 	//OC1 with timer 2 
.................... 	set_compare_time(1, duty_X, duty_X); 
1390:  PUSH    8A0
1392:  POP     182
1394:  PUSH    8A0
1396:  POP     180
.................... 	setup_compare(1, COMPARE_PWM | COMPARE_TIMER2); 
1398:  MOV     #6,W4
139A:  MOV     W4,184
.................... 	//OC2 with timer 2 
.................... 	set_compare_time(2, duty_Y, duty_Y); 
139C:  PUSH    8A2
139E:  POP     188
13A0:  PUSH    8A2
13A2:  POP     186
.................... 	setup_compare(2, COMPARE_PWM | COMPARE_TIMER2); 
13A4:  MOV     #6,W4
13A6:  MOV     W4,18A
.................... 	//set_timer2 
.................... 	set_timer2(0); 
13A8:  CLR     106
.................... 	setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1, 999);	 
13AA:  CLR     110
13AC:  MOV     #3E7,W4
13AE:  MOV     W4,10C
13B0:  MOV     #8000,W4
13B2:  MOV     W4,110
.................... 	return; 
13B4:  MOV     [--W15],W5
13B6:  RETURN  
.................... } 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                          Interupt FUNCTIONS                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #INT_TIMER4 
.................... static void Timer4ISR(void) 
*
0E22:  PUSH    42
0E24:  PUSH    36
0E26:  PUSH    32
0E28:  MOV     W0,[W15++]
0E2A:  MOV     #2,W0
0E2C:  REPEAT  #C
0E2E:  MOV     [W0++],[W15++]
.................... { 
.................... 	ReadPortA = input_a() & 0x0014; 
0E30:  MOV     2C2,W5
0E32:  AND     W5,#14,W0
0E34:  MOV     W0,818
.................... 	//AX0 
.................... 	AX0_New[SamplingCounterAX0] = (ReadPortA & 0x0004) >> 2; 
0E36:  MOV     #1,W4
0E38:  CLR.B   9
0E3A:  MOV     808,W0
0E3C:  MOV     80A,W1
0E3E:  INC     W4,W4
0E40:  DEC     W4,W4
0E42:  BRA     Z,E4A
0E44:  SL      W0,W0
0E46:  RLC     W1,W1
0E48:  BRA     E40
0E4A:  MOV     #82C,W4
0E4C:  ADD     W0,W4,W5
0E4E:  MOV     818,W0
0E50:  AND     W0,#4,W6
0E52:  LSR     W6,#2,W0
0E54:  MOV     W0,[W5]
.................... 	if((AX0_New[0] == AX0_New[1]) && (AX0_New[1] == AX0_New[2])) 
0E56:  MOV     82C,W0
0E58:  CP      82E
0E5A:  BRA     NZ,EAC
0E5C:  MOV     82E,W0
0E5E:  CP      830
0E60:  BRA     NZ,EAC
.................... 	{ 
.................... 		AX0_New_Actual = AX0_New[SamplingCounterAX0]; 
0E62:  MOV     #1,W4
0E64:  CLR.B   9
0E66:  MOV     808,W0
0E68:  MOV     80A,W1
0E6A:  INC     W4,W4
0E6C:  DEC     W4,W4
0E6E:  BRA     Z,E76
0E70:  SL      W0,W0
0E72:  RLC     W1,W1
0E74:  BRA     E6C
0E76:  MOV     #82C,W4
0E78:  ADD     W0,W4,W0
0E7A:  MOV     [W0],[W15++]
0E7C:  POP     824
.................... 		if(AX0_New_Actual != AX0_Old) 
0E7E:  MOV     824,W0
0E80:  CP      81C
0E82:  BRA     Z,EAC
.................... 		{ 
.................... 			AX0_Old = AX0_New_Actual; 
0E84:  PUSH    824
0E86:  POP     81C
.................... 			Sampling = 1; 
0E88:  MOV     #1,W4
0E8A:  MOV     W4,84A
.................... 			if((AX0_Old ^ AX1_Old) == 0) 
0E8C:  MOV     81C,W0
0E8E:  XOR     81E,W0
0E90:  MOV     W0,W5
0E92:  CP0     W5
0E94:  BRA     NZ,EA2
.................... 			{ 
.................... 				PulseCounter1++; 
0E96:  INC     0858
0E98:  BTSC.B  42.1
0E9A:  INC     085A
.................... 				RotateX = CW; 
0E9C:  MOV.B   #2,W0L
0E9E:  MOV.B   W0L,845
.................... 			} 
0EA0:  BRA     EAC
.................... 			else 
.................... 			{ 
.................... 				PulseCounter1--; 
0EA2:  DEC     0858
0EA4:  BTSS.B  42.0
0EA6:  DEC     085A
.................... 				RotateX = CCW; 
0EA8:  MOV.B   #1,W0L
0EAA:  MOV.B   W0L,845
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	SamplingCounterAX0++; 
0EAC:  INC     0808
0EAE:  BTSC.B  42.1
0EB0:  INC     080A
.................... 	if(SamplingCounterAX0 == REPEAT_SAMPLING) 
0EB2:  MOV     808,W4
0EB4:  CP      W4,#3
0EB6:  BRA     NZ,EC0
0EB8:  CP0     80A
0EBA:  BRA     NZ,EC0
.................... 	{ 
.................... 		SamplingCounterAX0 = 0; 
0EBC:  CLR     808
0EBE:  CLR     80A
.................... 	} 
.................... 	//AX1 
.................... 	AX1_New[SamplingCounterAX1] = (ReadPortA & 0x0010) >> 4; 
0EC0:  MOV     #1,W4
0EC2:  CLR.B   9
0EC4:  MOV     80C,W0
0EC6:  MOV     80E,W1
0EC8:  INC     W4,W4
0ECA:  DEC     W4,W4
0ECC:  BRA     Z,ED4
0ECE:  SL      W0,W0
0ED0:  RLC     W1,W1
0ED2:  BRA     ECA
0ED4:  MOV     #832,W4
0ED6:  ADD     W0,W4,W5
0ED8:  MOV     818,W0
0EDA:  AND     W0,#10,W6
0EDC:  LSR     W6,#4,W0
0EDE:  MOV     W0,[W5]
.................... 	if((AX1_New[0] == AX1_New[1]) && (AX1_New[1] == AX1_New[2])) 
0EE0:  MOV     832,W0
0EE2:  CP      834
0EE4:  BRA     NZ,F36
0EE6:  MOV     834,W0
0EE8:  CP      836
0EEA:  BRA     NZ,F36
.................... 	{ 
.................... 		AX1_New_Actual = AX1_New[SamplingCounterAX1]; 
0EEC:  MOV     #1,W4
0EEE:  CLR.B   9
0EF0:  MOV     80C,W0
0EF2:  MOV     80E,W1
0EF4:  INC     W4,W4
0EF6:  DEC     W4,W4
0EF8:  BRA     Z,F00
0EFA:  SL      W0,W0
0EFC:  RLC     W1,W1
0EFE:  BRA     EF6
0F00:  MOV     #832,W4
0F02:  ADD     W0,W4,W0
0F04:  MOV     [W0],[W15++]
0F06:  POP     826
.................... 		if(AX1_New_Actual != AX1_Old) 
0F08:  MOV     826,W0
0F0A:  CP      81E
0F0C:  BRA     Z,F36
.................... 		{ 
.................... 			AX1_Old = AX1_New_Actual; 
0F0E:  PUSH    826
0F10:  POP     81E
.................... 			Sampling = 1; 
0F12:  MOV     #1,W4
0F14:  MOV     W4,84A
.................... 			if((AX0_Old ^ AX1_Old) == 0) 
0F16:  MOV     81C,W0
0F18:  XOR     81E,W0
0F1A:  MOV     W0,W5
0F1C:  CP0     W5
0F1E:  BRA     NZ,F2C
.................... 			{ 
.................... 				PulseCounter1--; 
0F20:  DEC     0858
0F22:  BTSS.B  42.0
0F24:  DEC     085A
.................... 				RotateX = CCW; 
0F26:  MOV.B   #1,W0L
0F28:  MOV.B   W0L,845
.................... 			} 
0F2A:  BRA     F36
.................... 			else 
.................... 			{ 
.................... 				PulseCounter1++; 
0F2C:  INC     0858
0F2E:  BTSC.B  42.1
0F30:  INC     085A
.................... 				RotateX = CW; 
0F32:  MOV.B   #2,W0L
0F34:  MOV.B   W0L,845
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	SamplingCounterAX1++; 
0F36:  INC     080C
0F38:  BTSC.B  42.1
0F3A:  INC     080E
.................... 	if(SamplingCounterAX1 == REPEAT_SAMPLING) 
0F3C:  MOV     80C,W4
0F3E:  CP      W4,#3
0F40:  BRA     NZ,F4A
0F42:  CP0     80E
0F44:  BRA     NZ,F4A
.................... 	{ 
.................... 		SamplingCounterAX1 = 0; 
0F46:  CLR     80C
0F48:  CLR     80E
.................... 	} 
.................... } 
....................  
0F4A:  BCLR.B  87.3
0F4C:  MOV     #1A,W0
0F4E:  REPEAT  #C
0F50:  MOV     [--W15],[W0--]
0F52:  MOV     [--W15],W0
0F54:  POP     32
0F56:  POP     36
0F58:  POP     42
0F5A:  RETFIE  
.................... #INT_TIMER5 
.................... static void Timer5ISR(void) 
0F5C:  PUSH    42
0F5E:  PUSH    36
0F60:  PUSH    32
0F62:  MOV     W0,[W15++]
0F64:  MOV     #2,W0
0F66:  REPEAT  #C
0F68:  MOV     [W0++],[W15++]
.................... { 
.................... 	ReadPortB = input_b() & 0x000C; 
0F6A:  MOV     2CA,W5
0F6C:  AND     W5,#C,W0
0F6E:  MOV     W0,81A
.................... 	//AX2 
.................... 	AX2_New[SamplingCounterAX2] = (ReadPortB & 0x0004) >> 2; 
0F70:  MOV     #1,W4
0F72:  CLR.B   9
0F74:  MOV     810,W0
0F76:  MOV     812,W1
0F78:  INC     W4,W4
0F7A:  DEC     W4,W4
0F7C:  BRA     Z,F84
0F7E:  SL      W0,W0
0F80:  RLC     W1,W1
0F82:  BRA     F7A
0F84:  MOV     #838,W4
0F86:  ADD     W0,W4,W5
0F88:  MOV     81A,W0
0F8A:  AND     W0,#4,W6
0F8C:  LSR     W6,#2,W0
0F8E:  MOV     W0,[W5]
.................... 	if((AX2_New[0] == AX2_New[1]) && (AX2_New[1] == AX2_New[2])) 
0F90:  MOV     838,W0
0F92:  CP      83A
0F94:  BRA     NZ,FE6
0F96:  MOV     83A,W0
0F98:  CP      83C
0F9A:  BRA     NZ,FE6
.................... 	{ 
.................... 		AX2_New_Actual = AX2_New[SamplingCounterAX0]; 
0F9C:  MOV     #1,W4
0F9E:  CLR.B   9
0FA0:  MOV     808,W0
0FA2:  MOV     80A,W1
0FA4:  INC     W4,W4
0FA6:  DEC     W4,W4
0FA8:  BRA     Z,FB0
0FAA:  SL      W0,W0
0FAC:  RLC     W1,W1
0FAE:  BRA     FA6
0FB0:  MOV     #838,W4
0FB2:  ADD     W0,W4,W0
0FB4:  MOV     [W0],[W15++]
0FB6:  POP     828
.................... 		if(AX2_New_Actual != AX2_Old) 
0FB8:  MOV     828,W0
0FBA:  CP      820
0FBC:  BRA     Z,FE6
.................... 		{ 
.................... 			AX2_Old = AX2_New_Actual; 
0FBE:  PUSH    828
0FC0:  POP     820
.................... 			Sampling = 1; 
0FC2:  MOV     #1,W4
0FC4:  MOV     W4,84A
.................... 			if((AX2_Old ^ AX3_Old) == 0) 
0FC6:  MOV     820,W0
0FC8:  XOR     822,W0
0FCA:  MOV     W0,W5
0FCC:  CP0     W5
0FCE:  BRA     NZ,FDC
.................... 			{ 
.................... 				PulseCounter2++; 
0FD0:  INC     0868
0FD2:  BTSC.B  42.1
0FD4:  INC     086A
.................... 				RotateY = CW; 
0FD6:  MOV.B   #2,W0L
0FD8:  MOV.B   W0L,846
.................... 			} 
0FDA:  BRA     FE6
.................... 			else 
.................... 			{ 
.................... 				PulseCounter2--; 
0FDC:  DEC     0868
0FDE:  BTSS.B  42.0
0FE0:  DEC     086A
.................... 				RotateY = CCW; 
0FE2:  MOV.B   #1,W0L
0FE4:  MOV.B   W0L,846
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	SamplingCounterAX2++; 
0FE6:  INC     0810
0FE8:  BTSC.B  42.1
0FEA:  INC     0812
.................... 	if(SamplingCounterAX2 == REPEAT_SAMPLING) 
0FEC:  MOV     810,W4
0FEE:  CP      W4,#3
0FF0:  BRA     NZ,FFA
0FF2:  CP0     812
0FF4:  BRA     NZ,FFA
.................... 	{ 
.................... 		SamplingCounterAX2 = 0; 
0FF6:  CLR     810
0FF8:  CLR     812
.................... 	} 
.................... 	//AX3 
.................... 	AX3_New[SamplingCounterAX3] = (ReadPortB & 0x0008) >> 3; 
0FFA:  MOV     #1,W4
0FFC:  CLR.B   9
0FFE:  MOV     814,W0
1000:  MOV     816,W1
1002:  INC     W4,W4
1004:  DEC     W4,W4
1006:  BRA     Z,100E
1008:  SL      W0,W0
100A:  RLC     W1,W1
100C:  BRA     1004
100E:  MOV     #83E,W4
1010:  ADD     W0,W4,W5
1012:  MOV     81A,W0
1014:  AND     W0,#8,W6
1016:  LSR     W6,#3,W0
1018:  MOV     W0,[W5]
.................... 	if((AX3_New[0] == AX3_New[1]) && (AX3_New[1] == AX3_New[2])) 
101A:  MOV     83E,W0
101C:  CP      840
101E:  BRA     NZ,1070
1020:  MOV     840,W0
1022:  CP      842
1024:  BRA     NZ,1070
.................... 	{ 
.................... 		AX3_New_Actual = AX3_New[SamplingCounterAX3]; 
1026:  MOV     #1,W4
1028:  CLR.B   9
102A:  MOV     814,W0
102C:  MOV     816,W1
102E:  INC     W4,W4
1030:  DEC     W4,W4
1032:  BRA     Z,103A
1034:  SL      W0,W0
1036:  RLC     W1,W1
1038:  BRA     1030
103A:  MOV     #83E,W4
103C:  ADD     W0,W4,W0
103E:  MOV     [W0],[W15++]
1040:  POP     82A
.................... 		if(AX3_New_Actual != AX3_Old) 
1042:  MOV     82A,W0
1044:  CP      822
1046:  BRA     Z,1070
.................... 		{ 
.................... 			AX3_Old = AX3_New_Actual; 
1048:  PUSH    82A
104A:  POP     822
.................... 			Sampling = 1; 
104C:  MOV     #1,W4
104E:  MOV     W4,84A
.................... 			if((AX2_Old ^ AX3_Old) == 0) 
1050:  MOV     820,W0
1052:  XOR     822,W0
1054:  MOV     W0,W5
1056:  CP0     W5
1058:  BRA     NZ,1066
.................... 			{ 
.................... 				PulseCounter2--; 
105A:  DEC     0868
105C:  BTSS.B  42.0
105E:  DEC     086A
.................... 				RotateY = CCW; 
1060:  MOV.B   #1,W0L
1062:  MOV.B   W0L,846
.................... 			} 
1064:  BRA     1070
.................... 			else 
.................... 			{ 
.................... 				PulseCounter2++; 
1066:  INC     0868
1068:  BTSC.B  42.1
106A:  INC     086A
.................... 				RotateY = CW; 
106C:  MOV.B   #2,W0L
106E:  MOV.B   W0L,846
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	SamplingCounterAX3++; 
1070:  INC     0814
1072:  BTSC.B  42.1
1074:  INC     0816
.................... 	if(SamplingCounterAX3 == REPEAT_SAMPLING) 
1076:  MOV     814,W4
1078:  CP      W4,#3
107A:  BRA     NZ,1084
107C:  CP0     816
107E:  BRA     NZ,1084
.................... 	{ 
.................... 		SamplingCounterAX3 = 0; 
1080:  CLR     814
1082:  CLR     816
.................... 	} 
.................... } 
....................  
1084:  BCLR.B  87.4
1086:  MOV     #1A,W0
1088:  REPEAT  #C
108A:  MOV     [--W15],[W0--]
108C:  MOV     [--W15],W0
108E:  POP     32
1090:  POP     36
1092:  POP     42
1094:  RETFIE  
.................... #INT_Timer3 
.................... static void Timer3ISR(void) 
*
11EE:  PUSH    42
11F0:  PUSH    36
11F2:  PUSH    32
11F4:  MOV     W0,[W15++]
11F6:  MOV     #2,W0
11F8:  REPEAT  #C
11FA:  MOV     [W0++],[W15++]
.................... { 
.................... 	Tmr3IntrCounter++; 
11FC:  INC     0848
.................... 	//Axis1 
.................... 	PulseCounterNew1 = PulseCounter1; 
11FE:  PUSH    858
1200:  POP     850
1202:  PUSH    85A
1204:  POP     852
.................... 	PulseCounterInterval1 = PulseCounterNew1 - PulseCounterOld1; 
1206:  MOV     850,W4
1208:  MOV     84C,W3
120A:  SUB     W4,W3,W0
120C:  MOV     W0,854
120E:  MOV     852,W4
1210:  MOV     84E,W3
1212:  SUBB    W4,W3,W0
1214:  MOV     W0,856
.................... 	PulseCounterOld1 = PulseCounterNew1; 
1216:  PUSH    850
1218:  POP     84C
121A:  PUSH    852
121C:  POP     84E
.................... 	//Axis2 
.................... 	PulseCounterNew2 = PulseCounter2; 
121E:  PUSH    868
1220:  POP     860
1222:  PUSH    86A
1224:  POP     862
.................... 	PulseCounterInterval2 = PulseCounterNew2 - PulseCounterOld2; 
1226:  MOV     860,W4
1228:  MOV     85C,W3
122A:  SUB     W4,W3,W0
122C:  MOV     W0,864
122E:  MOV     862,W4
1230:  MOV     85E,W3
1232:  SUBB    W4,W3,W0
1234:  MOV     W0,866
.................... 	PulseCounterOld2 = PulseCounterNew2; 
1236:  PUSH    860
1238:  POP     85C
123A:  PUSH    862
123C:  POP     85E
.................... 	printf("e: %d, u: %d ,Pulse: %d\r\n",e_X,u_X,PulseCounter1); 
123E:  BTSC.B  223.1
1240:  BRA     123E
1242:  MOV     #65,W4
1244:  MOV     W4,224
1246:  BTSC.B  223.1
1248:  BRA     1246
124A:  MOV     #3A,W4
124C:  MOV     W4,224
124E:  BTSC.B  223.1
1250:  BRA     124E
1252:  MOV     #20,W4
1254:  MOV     W4,224
1256:  MOV     870,W0
1258:  MOV     872,W1
125A:  MOV     #0,W4
125C:  CALL    10DA
1260:  MOV     #5,W1
1262:  MOV     W1,W0
1264:  CLR.B   1
1266:  CALL    DFC
126A:  INC     W1,W1
126C:  BTSC.B  223.1
126E:  BRA     126C
1270:  MOV     W0,224
1272:  MOV     #9,W0
1274:  CPSGT   W1,W0
1276:  BRA     1262
1278:  MOV     86C,W0
127A:  MOV     86E,W1
127C:  MOV     #0,W4
127E:  CALL    10DA
1282:  MOV     #C,W1
1284:  MOV     W1,W0
1286:  CLR.B   1
1288:  CALL    DFC
128C:  INC     W1,W1
128E:  BTSC.B  223.1
1290:  BRA     128E
1292:  MOV     W0,224
1294:  MOV     #14,W0
1296:  CPSGT   W1,W0
1298:  BRA     1284
129A:  MOV     858,W0
129C:  MOV     85A,W1
129E:  MOV     #0,W4
12A0:  CALL    10DA
12A4:  BTSC.B  223.1
12A6:  BRA     12A4
12A8:  MOV     #D,W4
12AA:  MOV     W4,224
12AC:  BTSC.B  223.1
12AE:  BRA     12AC
12B0:  MOV     #A,W4
12B2:  MOV     W4,224
.................... 	return; 
12B4:  BCLR.B  85.0
12B6:  MOV     #1A,W0
12B8:  REPEAT  #C
12BA:  MOV     [--W15],[W0--]
12BC:  MOV     [--W15],W0
12BE:  POP     32
12C0:  POP     36
12C2:  POP     42
12C4:  RETFIE  
.................... } 
.................... /****************************************************************************/ 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                                 EOF                                    **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9C7   NOPR NOALTI2C1 NOIOL1WAY OSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
