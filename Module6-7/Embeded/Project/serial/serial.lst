CCS PCD C Compiler, Version 5.015, 5967               14-Nov-17 00:20

               Filename:   D:\chin\mine BCH project\Module6-7\Embeded\Project\serial\serial.lst

               ROM used:   2476 bytes (7%)
                           Largest free fragment is 31312
               RAM used:   331 (4%) at main() level
                           441 (5%) worst case
               Stack size: 128

*
0000:  GOTO    876
*
002A:  DATA    72,04,00
002C:  DATA    BA,05,00
.................... #import(file="EVENT_DRIVEN_CCS.o") 
.................... /* 
.................... *************************** C SOURCE FILE ************************************ 
....................  
.................... project   : 
.................... filename  : EVENT_DRIVEN_CCS.C 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #define EVENT_DRIVEN_CCS_C_SRC 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             MODULES USED                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "EVENT_DRIVEN_CCS.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : EVENT_DRIVEN_CCS.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  EVENT_DRIVEN_CCS_INCLUDED 
.................... #define  EVENT_DRIVEN_CCS_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "CONFIG_PIC24.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
....................  
.................... #list 
....................  
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 0 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B6 
.................... #pin_select INT2 = PIN_B5 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
....................  
.................... #pin_select OC1 = PIN_B0  // RP0  AX2 
.................... #pin_select OC2 = PIN_B1  // RP1  AX3 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
*
0772:  MOV     W5,[W15++]
0774:  MOV     W6,[W15++]
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
0776:  PUSH    8D6
0778:  POP     8D8
077A:  MOV     8D8,W0
077C:  MOV.B   [W0],W5L
077E:  SE      W5,W5
0780:  CP0     W5
0782:  BRA     Z,788
0784:  INC     08D8
0786:  BRA     77A
....................    return(sc - s); 
0788:  MOV     8D8,W4
078A:  MOV     8D6,W3
078C:  SUB     W4,W3,W0
078E:  MOV     [--W15],W6
0790:  MOV     [--W15],W5
0792:  RETURN  
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
*
0368:  MOV     W5,[W15++]
.................... { 
....................    node_t *result; 
....................    result =ptr; 
036A:  PUSH    92E
036C:  POP     930
....................    result->size=size; 
036E:  MOV     #0,W0
0370:  ADD     930,W0
0372:  MOV     W0,W5
0374:  MOV     92C,W4
0376:  MOV     W4,[W5+#0]
....................    result->next = NULL; 
0378:  MOV     #2,W0
037A:  ADD     930,W0
037C:  MOV     W0,W5
037E:  CLR.B   [W5]
0380:  MOV.B   #0,W0L
0382:  MOV.B   W0L,[W5+#1]
....................    return result; 
0384:  PUSH    930
0386:  POP     0
0388:  MOV     [--W15],W5
038A:  RETURN  
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
*
026A:  MOV     W5,[W15++]
.................... { 
....................    node->size=size; 
026C:  MOV     #0,W0
026E:  ADD     936,W0
0270:  MOV     W0,W5
0272:  MOV     938,W4
0274:  MOV     W4,[W5+#0]
0276:  MOV     [--W15],W5
0278:  RETURN  
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
*
038C:  MOV     W5,[W15++]
.................... { 
....................     if (place->next==NULL) 
038E:  MOV     #2,W0
0390:  ADD     922,W0
0392:  MOV     [W0],W5
0394:  CP0     W5
0396:  BRA     NZ,3A6
....................        node->next= NULL; 
0398:  MOV     #2,W0
039A:  ADD     924,W0
039C:  MOV     W0,W5
039E:  CLR.B   [W5]
03A0:  MOV.B   #0,W0L
03A2:  MOV.B   W0L,[W5+#1]
03A4:  BRA     3B2
....................     else 
....................        node->next=place->next; 
03A6:  MOV     #2,W0
03A8:  ADD     924,W0
03AA:  MOV     W0,W5
03AC:  MOV     #2,W0
03AE:  ADD     922,W0
03B0:  MOV     [W0],[W5]
....................     place->next=node; 
03B2:  MOV     #2,W0
03B4:  ADD     922,W0
03B6:  MOV     W0,W5
03B8:  MOV     924,W4
03BA:  MOV     W4,[W5+#0]
03BC:  MOV     [--W15],W5
03BE:  RETURN  
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
*
027A:  MOV     W5,[W15++]
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
027C:  PUSH    806
027E:  POP     936
0280:  MOV     #2,W0
0282:  ADD     936,W0
0284:  MOV     [W0],W5
0286:  MOV     934,W4
0288:  CP      W4,W5
028A:  BRA     Z,296
028C:  MOV     #2,W0
028E:  ADD     936,W0
0290:  MOV     [W0],[W15++]
0292:  POP     936
0294:  BRA     280
....................    ptr->next=node->next; 
0296:  MOV     #2,W0
0298:  ADD     936,W0
029A:  MOV     W0,W5
029C:  MOV     #2,W0
029E:  ADD     934,W0
02A0:  MOV     [W0],[W5]
....................    node=NULL; 
02A2:  CLR     934
02A4:  MOV     [--W15],W5
02A6:  RETURN  
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
02A8:  MOV     W5,[W15++]
02AA:  MOV     W6,[W15++]
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
02AC:  PUSH    806
02AE:  POP     91C
....................    while(node!=NULL) 
02B0:  CP0     91C
02B2:  BRA     Z,320
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
02B4:  MOV     #0,W0
02B6:  ADD     91C,W0
02B8:  MOV     [W0],W5
02BA:  BTSC    W5.F
02BC:  BRA     316
....................       { 
....................          nsize=node->size; 
02BE:  MOV     #0,W0
02C0:  ADD     91C,W0
02C2:  MOV     [W0],[W15++]
02C4:  POP     920
....................          temp=(unsigned int16)node->next; 
02C6:  MOV     #2,W0
02C8:  ADD     91C,W0
02CA:  MOV     [W0],[W15++]
02CC:  POP     91E
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
02CE:  MOV     #0,W0
02D0:  ADD     91E,W0
02D2:  MOV     [W0],W5
02D4:  BTSC    W5.F
02D6:  BRA     30C
02D8:  MOV     91C,W0
02DA:  ADD     920,W0
02DC:  MOV     W0,W6
02DE:  ADD     W6,#4,W6
02E0:  MOV     W6,W0
02E2:  CP      91E
02E4:  BRA     NZ,30C
....................          { 
....................             nextsize=temp->size; 
02E6:  MOV     #0,W0
02E8:  ADD     91E,W0
02EA:  MOV     [W0],[W15++]
02EC:  POP     922
....................             nsize+=nextsize+sizeof(node_t); 
02EE:  MOV     922,W4
02F0:  ADD     W4,#4,W4
02F2:  MOV     W4,W0
02F4:  ADD     920
....................             remove_node(temp); 
02F6:  PUSH    91E
02F8:  POP     934
02FA:  CALL    27A
....................             update_node(node,nsize); 
02FE:  PUSH    91C
0300:  POP     936
0302:  PUSH    920
0304:  POP     938
0306:  CALL    26A
....................          } 
030A:  BRA     314
....................          else 
....................          node=node->next; 
030C:  MOV     #2,W0
030E:  ADD     91C,W0
0310:  MOV     [W0],[W15++]
0312:  POP     91C
....................       } 
0314:  BRA     31E
....................       else 
....................       node=node->next; 
0316:  MOV     #2,W0
0318:  ADD     91C,W0
031A:  MOV     [W0],[W15++]
031C:  POP     91C
031E:  BRA     2B0
....................    } 
0320:  MOV     [--W15],W6
0322:  MOV     [--W15],W5
0324:  RETURN  
.................... } 
....................  
.................... char *malloc(size_t size) 
*
03C0:  MOV     W5,[W15++]
03C2:  MOV     W6,[W15++]
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
03C4:  MOV     90A,W0
03C6:  AND     W0,#1,W0
03C8:  CP0     W0
03CA:  BRA     Z,3CE
....................       size++; 
03CC:  INC     090A
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
03CE:  PUSH    806
03D0:  POP     90C
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
03D2:  CP0     90C
03D4:  BRA     Z,458
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
03D6:  MOV     #0,W0
03D8:  ADD     90C,W0
03DA:  MOV     [W0],W5
03DC:  BTSC    W5.F
03DE:  BRA     44E
03E0:  MOV     #0,W0
03E2:  ADD     90C,W0
03E4:  MOV     [W0],W6
03E6:  MOV     90A,W4
03E8:  CP      W4,W6
03EA:  BRA     GTU,44E
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
03EC:  MOV     #0,W0
03EE:  ADD     90C,W0
03F0:  MOV     [W0],[W15++]
03F2:  POP     910
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
03F4:  MOV     90A,W4
03F6:  ADD     W4,#4,W4
03F8:  MOV     W4,W0
03FA:  MOV     910,W4
03FC:  CP      W4,W0
03FE:  BRA     LEU,43C
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
0400:  MOV     910,W4
0402:  MOV     90A,W3
0404:  SUB     W4,W3,W5
0406:  SUB     W5,#4,W5
0408:  MOV     90C,W4
040A:  ADD     W4,#4,W4
040C:  MOV     W4,W6
040E:  MOV     W6,W0
0410:  ADD     90A,W0
0412:  MOV     W0,W6
0414:  MOV     W5,92C
0416:  MOV     W6,92E
0418:  CALL    368
041C:  MOV     W0,90E
....................             insert_node_after(node,new); 
041E:  PUSH    90C
0420:  POP     922
0422:  PUSH    90E
0424:  POP     924
0426:  CALL    38C
....................             update_node(node,size+_MEMMGMT_CSIZE); 
042A:  MOV     #8000,W4
042C:  MOV     90A,W3
042E:  ADD     W3,W4,W5
0430:  PUSH    90C
0432:  POP     936
0434:  MOV     W5,938
0436:  CALL    26A
....................          } 
043A:  BRA     44C
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
043C:  MOV     #8000,W4
043E:  MOV     910,W3
0440:  ADD     W3,W4,W5
0442:  PUSH    90C
0444:  POP     936
0446:  MOV     W5,938
0448:  CALL    26A
....................          //end if 
....................          break; 
044C:  BRA     458
....................       }//end if 
....................       node=node->next; 
044E:  MOV     #2,W0
0450:  ADD     90C,W0
0452:  MOV     [W0],[W15++]
0454:  POP     90C
0456:  BRA     3D2
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
0458:  CP0     90C
045A:  BRA     NZ,462
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
045C:  CLR     0
045E:  BRA     46C
....................    } 
0460:  BRA     46C
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
0462:  MOV     90C,W4
0464:  ADD     W4,#4,W4
0466:  MOV     W4,W0
0468:  MOV     W0,0
046A:  BRA     46C
046C:  MOV     [--W15],W6
046E:  MOV     [--W15],W5
0470:  RETURN  
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
*
0326:  MOV     W5,[W15++]
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
0328:  CP0     908
032A:  BRA     NZ,330
....................       return; 
032C:  BRA     364
032E:  BRA     360
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
0330:  MOV     908,W4
0332:  SUB     W4,#4,W0
0334:  MOV     W0,90A
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
0336:  MOV     #0,W0
0338:  ADD     90A,W0
033A:  MOV     [W0],W5
033C:  BTSS    W5.F
033E:  BRA     35C
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
0340:  MOV     #0,W0
0342:  ADD     90A,W0
0344:  MOV     [W0],W5
0346:  MOV     #8000,W4
0348:  SUB     W5,W4,W0
034A:  MOV     W0,90C
....................          update_node(node,nsize); 
034C:  PUSH    90A
034E:  POP     936
0350:  PUSH    90C
0352:  POP     938
0354:  CALL    26A
....................          ptr=NULL; 
0358:  CLR     908
....................  
....................       } 
035A:  BRA     360
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
035C:  CLR     908
....................          return; 
035E:  BRA     364
....................       } 
....................    } 
....................    traverse(); 
0360:  CALL    2A8
0364:  MOV     [--W15],W5
0366:  RETURN  
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... //#include "BL_support.h" 
.................... /****************************************************************************/ 
.................... // o/p pins   
.................... #define  INA_X  PIN_B4 //DI0 
.................... #define  INB_X  PIN_B5 //DI1 
.................... #define  INA_Y  PIN_B6 //DI2 
.................... #define  INB_Y  PIN_B7 //DI3 
....................  
.................... // i/p pins   
.................... #define  ENA_X  PIN_A2 //DO0 
.................... #define  ENB_X  PIN_A4 //DO1 
.................... #define  ENA_Y  PIN_B2 //DO2 
.................... #define  ENB_Y  PIN_B3 //DO3 
.................... #define  SW_X1  PIN_A0 //AX0 
.................... #define  SW_X2  PIN_B10  
.................... #define  SW_Y1  PIN_A1 //AX1 
.................... #define  SW_Y2  PIN_B11 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.h" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
.................... #include "EVENT_TYPE_CCS.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CTEMPLATE.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  EVENT_TYPE_CCS_H_INCLUDED 
.................... #define  EVENT_TYPE_CCS_H_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... typedef enum  
.................... { 
.................... 	EV_NULL, 
.................... 	EV_TIMER1, 
.................... 	EV_TIMER2, 
.................... 	EV_TIMER3, 
.................... 	EV_STMR0, 
.................... 	EV_STMR1, 
.................... 	EV_STMR2, 
.................... 	EV_STMR3, 
.................... 	EV_STMR4, 
.................... 	EV_SW0, 
.................... 	EV_SW1, 
.................... 	EV_SW2, 
.................... 	EV_SW3, 
.................... 	EV_TBE1, 
.................... 	EV_RDA1, 
.................... 	EV_OC1, 
.................... 	EV_OC2, 
.................... 	EV_IC1, 
.................... 	EV_IC2, 
.................... 	EV_EXT0, 
.................... 	EV_EXT1, 
.................... 	EV_EXT2 
.................... }EV_TYPE; 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #define DECLARE_MEM(BLOCK_TYPE_DEF , MEM_ARRAY, STRUCT_Q_ARRAY, N_BLOCK);\ 
.................... PTR_STRUCT STRUCT_Q_ARRAY[N_BLOCK]; \ 
.................... BLOCK_TYPE_DEF MEM_ARRAY[N_BLOCK]; 
....................  
.................... /****************************************************************************/ 
.................... // Queue error code 
.................... #define Q_OK 0 
.................... #define Q_FULL 1 
.................... #define Q_EMPTY 2 
....................  
.................... #define SINGLE 0 
.................... #define REPEAT 1 
....................  
.................... #define ON 1 
.................... #define OFF 0 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... // Data type for Tick counter 
.................... typedef volatile int32u tickType; 
....................  
.................... //Event structure 
.................... typedef volatile struct  
.................... { 
.................... 	EV_TYPE evType; 
.................... 	void *evDataPtr; 
.................... } EV_STRUCT; 
....................  
.................... typedef volatile struct  
.................... { 
.................... 	int8u evQLength; 
.................... 	int8u evQCount; 
.................... 	int8u evQPut; 
.................... 	int8u evQGet; 
.................... 	EV_STRUCT *evQArray; 
.................... }EVQ_STRUCT; 
....................  
.................... // Event Queue function error codes 
.................... typedef enum 
.................... { 
.................... 	EVQ_OK, 
.................... 	EVQ_FULL, 
.................... 	EVQ_EMPTY 
.................... } Q_ERR; 
....................  
.................... // Struct of pointer for mem qeue array  
.................... typedef volatile struct voidPtrStruct 
.................... { 
.................... 	void *blockPtr; 
.................... } PTR_STRUCT; 
....................  
.................... // Structure type for Mem Control Block 
.................... typedef volatile struct memControlStruct 
.................... { 
.................... 	void *memPtr; 
.................... 	int16u qArrayLength; 
.................... 	int16u count; 
.................... 	int16u put; 
.................... 	int16u get; 
.................... 	PTR_STRUCT *qArrayPtr; // Pointer to array of pointer to void 
.................... 	 
.................... } MCB_STRUCT; 
....................  
.................... // struct type for queue of pointer 
.................... typedef volatile struct qPtrXStruct 
.................... { 
.................... 	int16u arrayLength; 
.................... 	int16u count; 
.................... 	int16u put; 
.................... 	int16u get; 
.................... 	PTR_STRUCT *arrayPtr; // Pointer to array of pointer to void 
.................... } QPTRX_STRUCT; 
....................  
.................... // struct type for queue of int8u 
.................... typedef volatile struct q8UStruct 
.................... { 
.................... 	int16u arrayLength; 
.................... 	int16u count; 
.................... 	int16u put; 
.................... 	int16u get; 
.................... 	int8u *arrayPtr; // Pointer to array of int8u	 
.................... } Q8UX_STRUCT; 
....................  
.................... //STimer struct 
.................... typedef volatile struct  
.................... { 
.................... 	int8u tmrEnb; //enable (ON) / disable (OFF) software timer 
.................... 	int8u tmrMode; // Opareting mode : SINGLE / REPEAT 
.................... 	tickType tmrInit; // Initial value of tick count 
.................... 	tickType tmrCount; // Down counter value 
.................... 	EVQ_STRUCT *evQPtr; // Pointer to event queue 
.................... 	EV_STRUCT sTmrEvStruct; // Software Timer Event  Struct  
.................... } STMR_STRUCT; 
....................  
.................... // RX Frame State 
.................... typedef volatile enum  
.................... { 
.................... 	FRAME_WAIT, 
.................... 	FRAME_PROGRESS 
.................... } FRAME_STATE; 
....................  
.................... // Tx State 
.................... typedef volatile enum  
.................... { 
.................... 	TX1_BUSY, 
.................... 	TX1_READY 
.................... } TX1_STATUS;   
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #ifndef EVENT_DRIVEN_CCS_C_SRC 
.................... extern volatile int16u EvQFullCount; 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //							Library Functions 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //							Event Queue Functions 
.................... /****************************************************************************/ 
.................... void EvStructInit (EV_STRUCT *evStruct, EV_TYPE evType, void *evDataPtr); 
....................  
.................... void EvQInit (EVQ_STRUCT *evQ, EV_STRUCT *evArray, int8u qL); 
....................  
.................... void EvQPut (EVQ_STRUCT *evQ, EV_STRUCT evSource, Q_ERR *errPtr); 
....................  
.................... void EvQGet (EVQ_STRUCT *evQ, EV_STRUCT *evDest, Q_ERR *errPtr); 
....................  
.................... int16u EVQCount (EVQ_STRUCT *evQ); 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //								Memory Functions  
.................... /****************************************************************************/ 
....................  
.................... void MemStructArrayInit (void *memArrayPtr, int16u blockByteSize, int16u nblock, PTR_STRUCT *memQArrayPtr, MCB_STRUCT *memQcbPtr); 
....................  
.................... void MemPtrPut (MCB_STRUCT *memQcbPtr, void *memBlockPtr, int8u *errPtr); 
....................  
.................... void MemPtrGet (MCB_STRUCT *memQcbPtr, PTR_STRUCT *destStructPtr, int8u *errPtr); 
....................  
.................... int16u MemQReadyCount (MCB_STRUCT *memQcbPtr); 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //								QPTXR Functions  
.................... /****************************************************************************/ 
.................... void QPtrXInit (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *buffPtr, int16u qL); 
....................  
.................... void QPtrXPut (QPTRX_STRUCT *qStructPtr, PTR_STRUCT ptrStruct, int8u *errPtr); 
....................  
.................... void QPtrXGet (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *destPtr, int8u *errPtr); 
....................  
.................... int16u QPtrXCount (QPTRX_STRUCT *qStructPtr); 
....................  
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //								Q8UX Functions  
.................... /****************************************************************************/ 
....................  
.................... void Q8UXInit (Q8UX_STRUCT *qStructPtr, int8u *buffPtr, int16u qL); 
....................  
.................... void Q8UXPut (Q8UX_STRUCT *qStructPtr, int8u dataSource, int8u *errPtr); 
....................  
.................... void Q8UXGet (Q8UX_STRUCT *qStructPtr, int8u *destPtr, int8u *errPtr); 
....................  
.................... int16u Q8UXCount (Q8UX_STRUCT *qStructPtr); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //								Software  Timer Function 
.................... /****************************************************************************/ 
....................  
.................... void SoftwareTimer (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr); 
....................  
.................... void STmrSystemDeInit (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr); 
....................  
.................... void STmrInit (STMR_STRUCT *sTmrPtr, int8u z, tickType initValue, int8u mode, EV_TYPE evType, void *evDataPtr, EVQ_STRUCT *evQPtr); 
....................  
.................... void STmrStart (STMR_STRUCT *sTmrPtr, int8u z); 
....................  
.................... void STmrPause (STMR_STRUCT *sTmrPtr, int8u z); 
....................  
.................... void STmrStop (STMR_STRUCT *sTmrPtr, int8u z);	 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //								CPU Dependent Functions 
.................... /****************************************************************************/ 
....................  
.................... void DisableIntr (void); 
....................  
.................... void EnableIntr (void); 
....................  
.................... void CpuIdle (void); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                      PROTOTYPES OF LOCAL FUNCTIONS                     **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED VARIABLES                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... volatile int16u EvQFullCount = 0; 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                            GLOBAL VARIABLES                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED FUNCTIONS                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //							Library Functions 
.................... /****************************************************************************/ 
....................  
.................... /***************************************************************************/ 
.................... //							Event Queue Functions 
.................... /***************************************************************************/ 
.................... void EvStructInit (EV_STRUCT *evStruct, EV_TYPE evType, void *evDataPtr) 
.................... { 
.................... 	evStruct->evType = evType; 
.................... 	evStruct->evDataPtr = evDataPtr; 
.................... } 
....................  
.................... void EvQInit (EVQ_STRUCT *evQ, EV_STRUCT *evArray, int8u qL) 
.................... { 
.................... 	evQ->evQLength = qL; 
.................... 	evQ->evQCount = 0; 
.................... 	evQ->evQPut = 0; 
.................... 	evQ->evQGet = 0; 
.................... 	evQ->evQArray = evArray; 
.................... } 
....................  
.................... void EvQPut (EVQ_STRUCT *evQ, EV_STRUCT evSource, Q_ERR *errPtr) 
.................... { 
.................... 	if (evQ->evQCount == evQ->evQLength) 
.................... 	{ 
.................... 		*errPtr = EVQ_FULL; 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		evQ->evQCount++; 
.................... 		evQ->evQArray[evQ->evQPut] = evSource; 
.................... 		evQ->evQPut ++ ; 
.................... 		if (evQ->evQPut == evQ->evQLength) 
.................... 		{ 
.................... 			evQ->evQPut = 0; 
.................... 		} 
.................... 		*errPtr = EVQ_OK; 
.................... 	} 
.................... } 
....................  
.................... void EvQGet (EVQ_STRUCT *evQ, EV_STRUCT *evDest, Q_ERR *errPtr) 
.................... { 
.................... 	EV_STRUCT tempEvDest; 
.................... 	if (evQ->evQCount == 0) 
.................... 	{ 
.................... 		*errPtr = EVQ_EMPTY; 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		evQ->evQCount--; 
.................... 		tempEvDest = evQ->evQArray[evQ->evQGet]; 
.................... 		*evDest = tempEvDest; 
.................... 		evQ->evQGet++; 
.................... 		if (evQ->evQGet == evQ->evQLength) 
.................... 		{ 
.................... 			evQ->evQGet = 0; 
.................... 		} 
.................... 		*errPtr = EVQ_OK; 
.................... 	} 
.................... } 
....................  
.................... int16u EvQCount (EVQ_STRUCT *evQ) 
.................... { 
.................... 	return evQ->evQCount; 
.................... } 
....................  
.................... /***************************************************************************/ 
.................... //							Memory Functions 
.................... /***************************************************************************/ 
....................  
.................... void MemStructArrayInit (void *memArrayPtr, int16u blockByteSize, int16u nBlock, PTR_STRUCT *memQArrayPtr, MCB_STRUCT *memQcbPtr) 
.................... { 
.................... 	int16u i; 
.................... 	for (i=0; i < nBlock; i++) 
.................... 	{ 
.................... 		memQArrayPtr[i].blockPtr = (void *)((int8u *)memArrayPtr + (blockByteSize * i));		 
.................... 	} 
.................... 	memQcbPtr->memPtr = memArrayPtr; 
.................... 	memQcbPtr->qArrayLength = nBlock; 
.................... 	memQcbPtr->count = nBlock; 
.................... 	memQcbPtr->put = 0; 
.................... 	memQcbPtr->get = 0; 
.................... 	memQcbPtr->qArrayPtr = memQArrayPtr; 
.................... } 
....................  
.................... void MemPtrPut (MCB_STRUCT *memQcbPtr, void *memBlockPtr, int8u *errPtr) 
.................... { 
.................... 	if (memQcbPtr->count == memQcbPtr->qArrayLength) 
.................... 	{ 
.................... 		*errPtr = Q_FULL; 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		memQcbPtr->count++; 
.................... 		memQcbPtr->qArrayPtr[memQcbPtr->put].blockPtr = memBlockPtr; 
.................... 		memQcbPtr->put++; 
.................... 		if (memQcbPtr->put == memQcbPtr->qArrayLength) 
.................... 		{ 
.................... 			memQcbPtr->put = 0; 
.................... 		} 
.................... 		*errPtr = 0; 
.................... 	} 
.................... } 
....................  
.................... void MemPtrGet (MCB_STRUCT *memQcbPtr, PTR_STRUCT *destStructPtr, int8u *errPtr) 
.................... { 
.................... 	if (memQcbPtr->count == 0) 
.................... 	{ 
.................... 		destStructPtr->blockPtr = (void *)NULL; 
.................... 		*errPtr = Q_EMPTY; 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		memQcbPtr->count --; 
.................... 		destStructPtr->blockPtr = memQcbPtr->qArrayPtr[memQcbPtr->get].blockPtr; 
.................... 		memQcbPtr->get++; 
.................... 		if (memQcbPtr->get == memQcbPtr->qArrayLength) 
.................... 		{ 
.................... 			memQcbPtr->get = 0; 
.................... 		} 
.................... 		*errPtr = Q_OK; 
.................... 	} 
.................... } 
....................  
.................... int16u MemQReadyCount (MCB_STRUCT *memQcbPtr) 
.................... { 
.................... 	return memQcbPtr->count; 
.................... } 
....................  
.................... /***************************************************************************/ 
.................... //							QPTRX Functions 
.................... /***************************************************************************/ 
....................  
.................... void QPtrXInit (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *buffPtr, int16u qL) 
*
0662:  MOV     W5,[W15++]
.................... { 
.................... 	qStructPtr->arrayLength = qL; 
0664:  MOV     #0,W0
0666:  ADD     8CC,W0
0668:  MOV     W0,W5
066A:  MOV     8D0,W4
066C:  MOV     W4,[W5+#0]
.................... 	qStructPtr->count = 0; 
066E:  MOV     #2,W0
0670:  ADD     8CC,W0
0672:  MOV     W0,W5
0674:  CLR.B   [W5]
0676:  MOV.B   #0,W0L
0678:  MOV.B   W0L,[W5+#1]
.................... 	qStructPtr->put = 0; 
067A:  MOV     #4,W0
067C:  ADD     8CC,W0
067E:  MOV     W0,W5
0680:  CLR.B   [W5]
0682:  MOV.B   #0,W0L
0684:  MOV.B   W0L,[W5+#1]
.................... 	qStructPtr->get = 0; 
0686:  MOV     #6,W0
0688:  ADD     8CC,W0
068A:  MOV     W0,W5
068C:  CLR.B   [W5]
068E:  MOV.B   #0,W0L
0690:  MOV.B   W0L,[W5+#1]
.................... 	qStructPtr->arrayPtr = buffPtr; 
0692:  MOV     #8,W0
0694:  ADD     8CC,W0
0696:  MOV     W0,W5
0698:  MOV     8CE,W4
069A:  MOV     W4,[W5+#0]
069C:  MOV     [--W15],W5
069E:  RETURN  
.................... } 
....................  
.................... void QPtrXPut (QPTRX_STRUCT *qStructPtr, PTR_STRUCT ptrStruct, int8u *errPtr) 
*
0200:  MOV     W5,[W15++]
0202:  MOV     W6,[W15++]
.................... { 
.................... 	if (qStructPtr->count == qStructPtr->arrayLength) 
0204:  MOV     #2,W0
0206:  ADD     90E,W0
0208:  MOV     [W0],W5
020A:  MOV     #0,W0
020C:  ADD     90E,W0
020E:  MOV     W0,W4
0210:  MOV     [W4],W0
0212:  CP      W5,W0
0214:  BRA     NZ,21E
.................... 	{ 
.................... 		*errPtr = Q_FULL; 
0216:  MOV     912,W5
0218:  MOV.B   #1,W0L
021A:  MOV.B   W0L,[W5]
.................... 	} 
021C:  BRA     264
.................... 	else 
.................... 	{ 
.................... 		qStructPtr->count++; 
021E:  MOV     #2,W0
0220:  ADD     90E,W0
0222:  MOV     W0,W5
0224:  INC     [W5],[W5]
.................... 		qStructPtr->arrayPtr[qStructPtr->put] = ptrStruct; 
0226:  MOV     #8,W0
0228:  ADD     90E,W0
022A:  MOV     [W0],W5
022C:  MOV     #4,W0
022E:  ADD     90E,W0
0230:  MOV     [W0],W6
0232:  SL      W6,#1,W0
0234:  ADD     W0,W5,W6
0236:  MOV     910,W4
0238:  MOV     W4,[W6+#0]
.................... 		qStructPtr->put++; 
023A:  MOV     #4,W0
023C:  ADD     90E,W0
023E:  MOV     W0,W5
0240:  INC     [W5],[W5]
.................... 		if (qStructPtr->put == qStructPtr->arrayLength) 
0242:  MOV     #4,W0
0244:  ADD     90E,W0
0246:  MOV     [W0],W5
0248:  MOV     #0,W0
024A:  ADD     90E,W0
024C:  MOV     W0,W4
024E:  MOV     [W4],W0
0250:  CP      W5,W0
0252:  BRA     NZ,260
.................... 		{ 
.................... 			qStructPtr->put = 0; 
0254:  MOV     #4,W0
0256:  ADD     90E,W0
0258:  MOV     W0,W5
025A:  CLR.B   [W5]
025C:  MOV.B   #0,W0L
025E:  MOV.B   W0L,[W5+#1]
.................... 		} 
.................... 		*errPtr = Q_OK; 
0260:  MOV     912,W5
0262:  CLR.B   [W5]
.................... 	} 
0264:  MOV     [--W15],W6
0266:  MOV     [--W15],W5
0268:  RETURN  
.................... } 
....................  
.................... void QPtrXGet (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *destPtr, int8u *errPtr) 
*
0708:  MOV     W5,[W15++]
070A:  MOV     W6,[W15++]
070C:  MOV     W7,[W15++]
.................... { 
.................... 	if (qStructPtr->count == 0) 
070E:  MOV     #2,W0
0710:  ADD     8CC,W0
0712:  MOV     [W0],W5
0714:  CP0     W5
0716:  BRA     NZ,720
.................... 	{ 
.................... 		*errPtr = Q_EMPTY; 
0718:  MOV     8D0,W5
071A:  MOV.B   #2,W0L
071C:  MOV.B   W0L,[W5]
.................... 	} 
071E:  BRA     76A
.................... 	else 
.................... 	{ 
.................... 		qStructPtr->count--; 
0720:  MOV     #2,W0
0722:  ADD     8CC,W0
0724:  MOV     W0,W5
0726:  DEC     [W5],[W5]
.................... 		destPtr->blockPtr = qStructPtr->arrayPtr[qStructPtr->get].blockPtr; 
0728:  MOV     #0,W0
072A:  ADD     8CE,W0
072C:  MOV     W0,W5
072E:  MOV     #8,W0
0730:  ADD     8CC,W0
0732:  MOV     [W0],W6
0734:  MOV     #6,W0
0736:  ADD     8CC,W0
0738:  MOV     [W0],W7
073A:  SL      W7,#1,W7
073C:  ADD     W6,W7,W0
073E:  MOV     [W0],[W5]
.................... 		qStructPtr->get++; 
0740:  MOV     #6,W0
0742:  ADD     8CC,W0
0744:  MOV     W0,W5
0746:  INC     [W5],[W5]
.................... 		if (qStructPtr->get == qStructPtr->arrayLength) 
0748:  MOV     #6,W0
074A:  ADD     8CC,W0
074C:  MOV     [W0],W5
074E:  MOV     #0,W0
0750:  ADD     8CC,W0
0752:  MOV     W0,W4
0754:  MOV     [W4],W0
0756:  CP      W5,W0
0758:  BRA     NZ,766
.................... 		{ 
.................... 			qStructPtr->get = 0; 
075A:  MOV     #6,W0
075C:  ADD     8CC,W0
075E:  MOV     W0,W5
0760:  CLR.B   [W5]
0762:  MOV.B   #0,W0L
0764:  MOV.B   W0L,[W5+#1]
.................... 		} 
.................... 		*errPtr = Q_OK; 
0766:  MOV     8D0,W5
0768:  CLR.B   [W5]
.................... 	} 
076A:  MOV     [--W15],W7
076C:  MOV     [--W15],W6
076E:  MOV     [--W15],W5
0770:  RETURN  
.................... } 
....................  
.................... int16u QPtrXCount (QPTRX_STRUCT *qStructPtr) 
.................... { 
.................... 	return qStructPtr->count; 
.................... } 
....................  
.................... /***************************************************************************/ 
.................... //							Q8UX Functions 
.................... /***************************************************************************/ 
....................  
.................... void Q8UXInit (Q8UX_STRUCT *qStructPtr, int8u *buffPtr, int16u qL) 
*
06A0:  MOV     W5,[W15++]
.................... { 
.................... 	qStructPtr->arrayLength = qL; 
06A2:  MOV     #0,W0
06A4:  ADD     8CC,W0
06A6:  MOV     W0,W5
06A8:  MOV     8D0,W4
06AA:  MOV     W4,[W5+#0]
.................... 	qStructPtr->count = 0; 
06AC:  MOV     #2,W0
06AE:  ADD     8CC,W0
06B0:  MOV     W0,W5
06B2:  CLR.B   [W5]
06B4:  MOV.B   #0,W0L
06B6:  MOV.B   W0L,[W5+#1]
.................... 	qStructPtr->put = 0; 
06B8:  MOV     #4,W0
06BA:  ADD     8CC,W0
06BC:  MOV     W0,W5
06BE:  CLR.B   [W5]
06C0:  MOV.B   #0,W0L
06C2:  MOV.B   W0L,[W5+#1]
.................... 	qStructPtr->get = 0; 
06C4:  MOV     #6,W0
06C6:  ADD     8CC,W0
06C8:  MOV     W0,W5
06CA:  CLR.B   [W5]
06CC:  MOV.B   #0,W0L
06CE:  MOV.B   W0L,[W5+#1]
.................... 	qStructPtr->arrayPtr = buffPtr; 
06D0:  MOV     #8,W0
06D2:  ADD     8CC,W0
06D4:  MOV     W0,W5
06D6:  MOV     8CE,W4
06D8:  MOV     W4,[W5+#0]
06DA:  MOV     [--W15],W5
06DC:  RETURN  
.................... } 
....................  
.................... void Q8UXPut (Q8UX_STRUCT *qStructPtr, int8u dataSource, int8u *errPtr) 
*
07A4:  MOV     W5,[W15++]
07A6:  MOV     W6,[W15++]
07A8:  MOV     W7,[W15++]
.................... { 
.................... 	if (qStructPtr->count == qStructPtr->arrayLength) 
07AA:  MOV     #2,W0
07AC:  ADD     8D8,W0
07AE:  MOV     [W0],W5
07B0:  MOV     #0,W0
07B2:  ADD     8D8,W0
07B4:  MOV     W0,W4
07B6:  MOV     [W4],W0
07B8:  CP      W5,W0
07BA:  BRA     NZ,7C4
.................... 	{ 
.................... 		*errPtr = Q_FULL; 
07BC:  MOV     8DC,W5
07BE:  MOV.B   #1,W0L
07C0:  MOV.B   W0L,[W5]
.................... 	} 
07C2:  BRA     808
.................... 	else 
.................... 	{ 
.................... 		qStructPtr->count ++; 
07C4:  MOV     #2,W0
07C6:  ADD     8D8,W0
07C8:  MOV     W0,W5
07CA:  INC     [W5],[W5]
.................... 		qStructPtr->arrayPtr[qStructPtr->put] = dataSource; 
07CC:  MOV     #8,W0
07CE:  ADD     8D8,W0
07D0:  MOV     [W0],W5
07D2:  MOV     #4,W0
07D4:  ADD     8D8,W0
07D6:  MOV     [W0],W6
07D8:  ADD     W5,W6,W7
07DA:  MOV     8DA,W0
07DC:  MOV.B   W0L,[W7+#0]
.................... 		qStructPtr->put++; 
07DE:  MOV     #4,W0
07E0:  ADD     8D8,W0
07E2:  MOV     W0,W5
07E4:  INC     [W5],[W5]
.................... 		if (qStructPtr->put == qStructPtr->arrayLength) 
07E6:  MOV     #4,W0
07E8:  ADD     8D8,W0
07EA:  MOV     [W0],W5
07EC:  MOV     #0,W0
07EE:  ADD     8D8,W0
07F0:  MOV     W0,W4
07F2:  MOV     [W4],W0
07F4:  CP      W5,W0
07F6:  BRA     NZ,804
.................... 		{ 
.................... 			qStructPtr->put = 0; 
07F8:  MOV     #4,W0
07FA:  ADD     8D8,W0
07FC:  MOV     W0,W5
07FE:  CLR.B   [W5]
0800:  MOV.B   #0,W0L
0802:  MOV.B   W0L,[W5+#1]
.................... 		} 
.................... 		*errPtr = Q_OK; 
0804:  MOV     8DC,W5
0806:  CLR.B   [W5]
.................... 	} 
0808:  MOV     [--W15],W7
080A:  MOV     [--W15],W6
080C:  MOV     [--W15],W5
080E:  RETURN  
.................... } 
....................  
.................... void Q8UXGet (Q8UX_STRUCT *qStructPtr, int8u *destPtr, int8u *errPtr) 
*
0556:  MOV     W5,[W15++]
0558:  MOV     W6,[W15++]
055A:  MOV     W7,[W15++]
.................... { 
.................... 	if (qStructPtr->count == 0) 
055C:  MOV     #2,W0
055E:  ADD     900,W0
0560:  MOV     [W0],W5
0562:  CP0     W5
0564:  BRA     NZ,56E
.................... 	{ 
.................... 		*errPtr = Q_EMPTY; 
0566:  MOV     904,W5
0568:  MOV.B   #2,W0L
056A:  MOV.B   W0L,[W5]
.................... 	} 
056C:  BRA     5B2
.................... 	else 
.................... 	{ 
.................... 		qStructPtr->count--; 
056E:  MOV     #2,W0
0570:  ADD     900,W0
0572:  MOV     W0,W5
0574:  DEC     [W5],[W5]
.................... 		*destPtr = qStructPtr->arrayPtr[qStructPtr->get]; 
0576:  MOV     902,W5
0578:  MOV     #8,W0
057A:  ADD     900,W0
057C:  MOV     [W0],W6
057E:  MOV     #6,W0
0580:  ADD     900,W0
0582:  MOV     [W0],W7
0584:  ADD     W6,W7,W0
0586:  MOV.B   [W0],[W5]
.................... 		qStructPtr->get++; 
0588:  MOV     #6,W0
058A:  ADD     900,W0
058C:  MOV     W0,W5
058E:  INC     [W5],[W5]
.................... 		if(qStructPtr->get == qStructPtr->arrayLength) 
0590:  MOV     #6,W0
0592:  ADD     900,W0
0594:  MOV     [W0],W5
0596:  MOV     #0,W0
0598:  ADD     900,W0
059A:  MOV     W0,W4
059C:  MOV     [W4],W0
059E:  CP      W5,W0
05A0:  BRA     NZ,5AE
.................... 		{ 
.................... 			qStructPtr->get = 0; 
05A2:  MOV     #6,W0
05A4:  ADD     900,W0
05A6:  MOV     W0,W5
05A8:  CLR.B   [W5]
05AA:  MOV.B   #0,W0L
05AC:  MOV.B   W0L,[W5+#1]
.................... 		} 
.................... 		*errPtr = Q_OK; 
05AE:  MOV     904,W5
05B0:  CLR.B   [W5]
.................... 	} 
05B2:  MOV     [--W15],W7
05B4:  MOV     [--W15],W6
05B6:  MOV     [--W15],W5
05B8:  RETURN  
.................... } 
....................  
.................... int16u Q8UXCount (Q8UX_STRUCT *qStructPtr) 
*
0794:  MOV     W5,[W15++]
.................... { 
.................... 	return qStructPtr->count; 
0796:  MOV     #2,W0
0798:  ADD     8D6,W0
079A:  MOV     W0,W5
079C:  MOV     [W5],[W15++]
079E:  POP     0
07A0:  MOV     [--W15],W5
07A2:  RETURN  
.................... } 
....................  
.................... /***************************************************************************/ 
.................... //							Q8UX Functions 
.................... /***************************************************************************/ 
....................  
.................... void SoftwareTimer (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr) 
.................... { 
.................... 	int8u k; 
.................... 	Q_ERR err; 
.................... 	for (k=0 ; k < nMaxSTmr; k++) 
.................... 	{ 
.................... 		if (sTmrPtr[k].tmrEnb == ON) 
.................... 		{ 
.................... 			sTmrPtr[k].tmrCount--; 
.................... 			if (sTmrPtr[k].tmrCount == 0) 
.................... 			{ 
.................... 				EvQPut (sTmrPtr[k].evQPtr, sTmrPtr[k].sTmrEvStruct, &err); 
.................... 				if (err == EVQ_FULL) 
.................... 				{ 
.................... 					EvQFullCount ++; 
.................... 				} 
.................... 				sTmrPtr[k].tmrCount = sTmrPtr[k].tmrInit; 
.................... 				if (sTmrPtr[k].tmrMode == SINGLE) 
.................... 				{ 
.................... 					sTmrPtr[k].tmrEnb = OFF; 
.................... 				} 
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*****************************************************************************/ 
....................  
.................... void STmrSystemDeInit (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr) 
.................... { 
.................... 	int8u k; 
.................... 	for (k=0; k<nMaxSTmr; k++) 
.................... 	{ 
.................... 		sTmrPtr[k].tmrEnb = OFF; 
.................... 		sTmrPtr[k].evQPtr = NULL; 
.................... 	} 
.................... } 
....................  
.................... /*****************************************************************************/ 
....................  
.................... void STmrInit (STMR_STRUCT *sTmrPtr, int8u z, tickType initValue, int8u mode, EV_TYPE evType, void *evDataPtr, EVQ_STRUCT *evQPtr) 
.................... { 
.................... 	sTmrPtr[z].tmrEnb = OFF; 
.................... 	sTmrPtr[z].tmrMode = mode; 
.................... 	sTmrPtr[z].tmrInit = initValue; 
.................... 	sTmrPtr[z].tmrCount = initValue; 
.................... 	sTmrPtr[z].evQPtr = evQPtr; 
.................... 	EvStructInit (&(sTmrPtr[z].sTmrEvStruct), evType, evDataPtr); 
.................... } 
....................  
.................... /*****************************************************************************/ 
....................  
.................... void STmrStart (STMR_STRUCT *sTmrPtr, int8u z) 
.................... { 
.................... 	Q_ERR err; 
.................... 	if (sTmrPtr[z].tmrEnb == OFF) 
.................... 	{ 
.................... 		if (sTmrPtr[z].tmrCount != 0) 
.................... 		{ 
.................... 			sTmrPtr[z].tmrEnb = ON; 
.................... 		} 
.................... 		else 
.................... 		{ 
.................... 			EvQPut (sTmrPtr[z].evQPtr, sTmrPtr[z].sTmrEvStruct, &err); 
.................... 			if (err == EVQ_FULL) 
.................... 			{ 
.................... 				EvQFullCount++; 
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... /*****************************************************************************/ 
....................  
.................... void STmrPause (STMR_STRUCT *sTmrPtr, int8u z) 
.................... { 
.................... 	(sTmrPtr + z)->tmrEnb = OFF; 
.................... } 
.................... /*****************************************************************************/ 
....................  
.................... void STmrStop (STMR_STRUCT *sTmrPtr, int8u z) 
.................... { 
.................... 	sTmrPtr[z].tmrEnb = OFF; 
.................... 	sTmrPtr[z].tmrCount = sTmrPtr[z].tmrInit; 
.................... } 
.................... /*****************************************************************************/ 
....................  
.................... /*****************************************************************************/ 
.................... //								CPU Dependent Functions 
.................... /*****************************************************************************/ 
....................  
.................... void DisableIntr(void) 
.................... { 
.................... 	disable_interrupts (INTR_GLOBAL); 
*
05FE:  BCLR.B  81.7
0600:  MOV     #E0,W4
0602:  MOV     W4,42
0604:  BSET.B  81.7
0606:  RETURN  
.................... } 
....................  
.................... void EnableIntr(void) 
.................... { 
.................... 	enable_interrupts (INTR_GLOBAL); 
*
0700:  BCLR.B  81.7
0702:  CLR     42
0704:  BSET.B  81.7
0706:  RETURN  
.................... } 
....................  
.................... void CpuIdle (void) 
.................... { 
.................... } 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             LOCAL FUNCTIONS                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                                 EOF                                    **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #import(file="PIC24_UART_INTERRUPT_01.o") 
.................... /* 
.................... *************************** C SOURCE FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CTEMPLATE.C 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #define PIC24_UART_INTERRUPT_01_C_SRC 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             MODULES USED                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "PIC24_UART_INTERRUPT_01.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CTEMPLATE.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  PIC24_UART_INTERRUPT_01_INCLUDED 
.................... #define  PIC24_UART_INTERRUPT_01_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
.................... #include "CONFIG_PIC24.h"   
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
....................  
.................... #list 
....................  
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 0 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B6 
.................... #pin_select INT2 = PIN_B5 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
....................  
.................... #pin_select OC1 = PIN_B0  // RP0  AX2 
.................... #pin_select OC2 = PIN_B1  // RP1  AX3 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... //#include "BL_support.h" 
.................... /****************************************************************************/ 
.................... // o/p pins   
.................... #define  INA_X  PIN_B4 //DI0 
.................... #define  INB_X  PIN_B5 //DI1 
.................... #define  INA_Y  PIN_B6 //DI2 
.................... #define  INB_Y  PIN_B7 //DI3 
....................  
.................... // i/p pins   
.................... #define  ENA_X  PIN_A2 //DO0 
.................... #define  ENB_X  PIN_A4 //DO1 
.................... #define  ENA_Y  PIN_B2 //DO2 
.................... #define  ENB_Y  PIN_B3 //DO3 
.................... #define  SW_X1  PIN_A0 //AX0 
.................... #define  SW_X2  PIN_B10  
.................... #define  SW_Y1  PIN_A1 //AX1 
.................... #define  SW_Y2  PIN_B11 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.h"   
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
.................... #include "EVENT_DRIVEN_CCS.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : EVENT_DRIVEN_CCS.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  EVENT_DRIVEN_CCS_INCLUDED 
.................... #define  EVENT_DRIVEN_CCS_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "CONFIG_PIC24.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 0 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B6 
.................... #pin_select INT2 = PIN_B5 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
....................  
.................... #pin_select OC1 = PIN_B0  // RP0  AX2 
.................... #pin_select OC2 = PIN_B1  // RP1  AX3 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... #include <stdio.h> 
.................... #include <stdlibm.h> 
.................... #include <string.h> 
.................... #include <stdint.h> 
.................... //#include "BL_support.h" 
.................... /****************************************************************************/ 
.................... // o/p pins   
.................... #define  INA_X  PIN_B4 //DI0 
.................... #define  INB_X  PIN_B5 //DI1 
.................... #define  INA_Y  PIN_B6 //DI2 
.................... #define  INB_Y  PIN_B7 //DI3 
....................  
.................... // i/p pins   
.................... #define  ENA_X  PIN_A2 //DO0 
.................... #define  ENB_X  PIN_A4 //DO1 
.................... #define  ENA_Y  PIN_B2 //DO2 
.................... #define  ENB_Y  PIN_B3 //DO3 
.................... #define  SW_X1  PIN_A0 //AX0 
.................... #define  SW_X2  PIN_B10  
.................... #define  SW_Y1  PIN_A1 //AX1 
.................... #define  SW_Y2  PIN_B11 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.h" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
.................... #include "EVENT_TYPE_CCS.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CTEMPLATE.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  EVENT_TYPE_CCS_H_INCLUDED 
.................... #define  EVENT_TYPE_CCS_H_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... typedef enum  
.................... { 
.................... 	EV_NULL, 
.................... 	EV_TIMER1, 
.................... 	EV_TIMER2, 
.................... 	EV_TIMER3, 
.................... 	EV_STMR0, 
.................... 	EV_STMR1, 
.................... 	EV_STMR2, 
.................... 	EV_STMR3, 
.................... 	EV_STMR4, 
.................... 	EV_SW0, 
.................... 	EV_SW1, 
.................... 	EV_SW2, 
.................... 	EV_SW3, 
.................... 	EV_TBE1, 
.................... 	EV_RDA1, 
.................... 	EV_OC1, 
.................... 	EV_OC2, 
.................... 	EV_IC1, 
.................... 	EV_IC2, 
.................... 	EV_EXT0, 
.................... 	EV_EXT1, 
.................... 	EV_EXT2 
.................... }EV_TYPE; 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #define DECLARE_MEM(BLOCK_TYPE_DEF , MEM_ARRAY, STRUCT_Q_ARRAY, N_BLOCK);\ 
.................... PTR_STRUCT STRUCT_Q_ARRAY[N_BLOCK]; \ 
.................... BLOCK_TYPE_DEF MEM_ARRAY[N_BLOCK]; 
....................  
.................... /****************************************************************************/ 
.................... // Queue error code 
.................... #define Q_OK 0 
.................... #define Q_FULL 1 
.................... #define Q_EMPTY 2 
....................  
.................... #define SINGLE 0 
.................... #define REPEAT 1 
....................  
.................... #define ON 1 
.................... #define OFF 0 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... // Data type for Tick counter 
.................... typedef volatile int32u tickType; 
....................  
.................... //Event structure 
.................... typedef volatile struct  
.................... { 
.................... 	EV_TYPE evType; 
.................... 	void *evDataPtr; 
.................... } EV_STRUCT; 
....................  
.................... typedef volatile struct  
.................... { 
.................... 	int8u evQLength; 
.................... 	int8u evQCount; 
.................... 	int8u evQPut; 
.................... 	int8u evQGet; 
.................... 	EV_STRUCT *evQArray; 
.................... }EVQ_STRUCT; 
....................  
.................... // Event Queue function error codes 
.................... typedef enum 
.................... { 
.................... 	EVQ_OK, 
.................... 	EVQ_FULL, 
.................... 	EVQ_EMPTY 
.................... } Q_ERR; 
....................  
.................... // Struct of pointer for mem qeue array  
.................... typedef volatile struct voidPtrStruct 
.................... { 
.................... 	void *blockPtr; 
.................... } PTR_STRUCT; 
....................  
.................... // Structure type for Mem Control Block 
.................... typedef volatile struct memControlStruct 
.................... { 
.................... 	void *memPtr; 
.................... 	int16u qArrayLength; 
.................... 	int16u count; 
.................... 	int16u put; 
.................... 	int16u get; 
.................... 	PTR_STRUCT *qArrayPtr; // Pointer to array of pointer to void 
.................... 	 
.................... } MCB_STRUCT; 
....................  
.................... // struct type for queue of pointer 
.................... typedef volatile struct qPtrXStruct 
.................... { 
.................... 	int16u arrayLength; 
.................... 	int16u count; 
.................... 	int16u put; 
.................... 	int16u get; 
.................... 	PTR_STRUCT *arrayPtr; // Pointer to array of pointer to void 
.................... } QPTRX_STRUCT; 
....................  
.................... // struct type for queue of int8u 
.................... typedef volatile struct q8UStruct 
.................... { 
.................... 	int16u arrayLength; 
.................... 	int16u count; 
.................... 	int16u put; 
.................... 	int16u get; 
.................... 	int8u *arrayPtr; // Pointer to array of int8u	 
.................... } Q8UX_STRUCT; 
....................  
.................... //STimer struct 
.................... typedef volatile struct  
.................... { 
.................... 	int8u tmrEnb; //enable (ON) / disable (OFF) software timer 
.................... 	int8u tmrMode; // Opareting mode : SINGLE / REPEAT 
.................... 	tickType tmrInit; // Initial value of tick count 
.................... 	tickType tmrCount; // Down counter value 
.................... 	EVQ_STRUCT *evQPtr; // Pointer to event queue 
.................... 	EV_STRUCT sTmrEvStruct; // Software Timer Event  Struct  
.................... } STMR_STRUCT; 
....................  
.................... // RX Frame State 
.................... typedef volatile enum  
.................... { 
.................... 	FRAME_WAIT, 
.................... 	FRAME_PROGRESS 
.................... } FRAME_STATE; 
....................  
.................... // Tx State 
.................... typedef volatile enum  
.................... { 
.................... 	TX1_BUSY, 
.................... 	TX1_READY 
.................... } TX1_STATUS;   
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #ifndef EVENT_DRIVEN_CCS_C_SRC 
.................... extern volatile int16u EvQFullCount; 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //							Library Functions 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //							Event Queue Functions 
.................... /****************************************************************************/ 
.................... void EvStructInit (EV_STRUCT *evStruct, EV_TYPE evType, void *evDataPtr); 
....................  
.................... void EvQInit (EVQ_STRUCT *evQ, EV_STRUCT *evArray, int8u qL); 
....................  
.................... void EvQPut (EVQ_STRUCT *evQ, EV_STRUCT evSource, Q_ERR *errPtr); 
....................  
.................... void EvQGet (EVQ_STRUCT *evQ, EV_STRUCT *evDest, Q_ERR *errPtr); 
....................  
.................... int16u EVQCount (EVQ_STRUCT *evQ); 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //								Memory Functions  
.................... /****************************************************************************/ 
....................  
.................... void MemStructArrayInit (void *memArrayPtr, int16u blockByteSize, int16u nblock, PTR_STRUCT *memQArrayPtr, MCB_STRUCT *memQcbPtr); 
....................  
.................... void MemPtrPut (MCB_STRUCT *memQcbPtr, void *memBlockPtr, int8u *errPtr); 
....................  
.................... void MemPtrGet (MCB_STRUCT *memQcbPtr, PTR_STRUCT *destStructPtr, int8u *errPtr); 
....................  
.................... int16u MemQReadyCount (MCB_STRUCT *memQcbPtr); 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //								QPTXR Functions  
.................... /****************************************************************************/ 
.................... void QPtrXInit (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *buffPtr, int16u qL); 
....................  
.................... void QPtrXPut (QPTRX_STRUCT *qStructPtr, PTR_STRUCT ptrStruct, int8u *errPtr); 
....................  
.................... void QPtrXGet (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *destPtr, int8u *errPtr); 
....................  
.................... int16u QPtrXCount (QPTRX_STRUCT *qStructPtr); 
....................  
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //								Q8UX Functions  
.................... /****************************************************************************/ 
....................  
.................... void Q8UXInit (Q8UX_STRUCT *qStructPtr, int8u *buffPtr, int16u qL); 
....................  
.................... void Q8UXPut (Q8UX_STRUCT *qStructPtr, int8u dataSource, int8u *errPtr); 
....................  
.................... void Q8UXGet (Q8UX_STRUCT *qStructPtr, int8u *destPtr, int8u *errPtr); 
....................  
.................... int16u Q8UXCount (Q8UX_STRUCT *qStructPtr); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //								Software  Timer Function 
.................... /****************************************************************************/ 
....................  
.................... void SoftwareTimer (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr); 
....................  
.................... void STmrSystemDeInit (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr); 
....................  
.................... void STmrInit (STMR_STRUCT *sTmrPtr, int8u z, tickType initValue, int8u mode, EV_TYPE evType, void *evDataPtr, EVQ_STRUCT *evQPtr); 
....................  
.................... void STmrStart (STMR_STRUCT *sTmrPtr, int8u z); 
....................  
.................... void STmrPause (STMR_STRUCT *sTmrPtr, int8u z); 
....................  
.................... void STmrStop (STMR_STRUCT *sTmrPtr, int8u z);	 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //								CPU Dependent Functions 
.................... /****************************************************************************/ 
....................  
.................... void DisableIntr (void); 
....................  
.................... void EnableIntr (void); 
....................  
.................... void CpuIdle (void); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "EVENT_TYPE_CCS.h"   
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CTEMPLATE.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  EVENT_TYPE_CCS_H_INCLUDED 
.................... #define  EVENT_TYPE_CCS_H_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... typedef enum  
.................... { 
.................... 	EV_NULL, 
.................... 	EV_TIMER1, 
.................... 	EV_TIMER2, 
.................... 	EV_TIMER3, 
.................... 	EV_STMR0, 
.................... 	EV_STMR1, 
.................... 	EV_STMR2, 
.................... 	EV_STMR3, 
.................... 	EV_STMR4, 
.................... 	EV_SW0, 
.................... 	EV_SW1, 
.................... 	EV_SW2, 
.................... 	EV_SW3, 
.................... 	EV_TBE1, 
.................... 	EV_RDA1, 
.................... 	EV_OC1, 
.................... 	EV_OC2, 
.................... 	EV_IC1, 
.................... 	EV_IC2, 
.................... 	EV_EXT0, 
.................... 	EV_EXT1, 
.................... 	EV_EXT2 
.................... }EV_TYPE; 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #ifndef PIC24_UART_INTERRUPT_01_C_SRC 
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //UART Rx frame 
.................... #define RX1Q_LN 8 
.................... #define RX_CMND_FRM_LN 16 
.................... #define START_CHR '<' 
.................... #define END_CHR '>' 
....................  
.................... //UART Queue 
.................... #define TX1Q_LN 128 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                      PROTOTYPES OF LOCAL FUNCTIONS                     **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... static void HardwareInit(); 
.................... static void GlobalVarInit(); 
.................... static void DynamicMemInit(); 
.................... static void UARTQueueInit(); 
.................... static int8u SendTx1(int8u *strPtr); 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED VARIABLES                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                            GLOBAL VARIABLES                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... static volatile Q8UX_STRUCT Tx1QCB; 
.................... static volatile int8u Tx1QArray[TX1Q_LN]; 
.................... static volatile int8u *Tx1BuffPtr; 
.................... static volatile int16u Tx1BuffIdx; 
.................... static volatile TX1_STATUS Tx1Flag; 
.................... static volatile int16u Tx1FrameIn, Tx1FrameOut, Rx1FrameCount,RxCount,Tx1QFullCount, Rx1QFullCount; 
.................... static volatile int8u *RxBuffPtr; 
.................... static volatile QPTRX_STRUCT Rx1QCB; 
.................... static volatile PTR_STRUCT Rx1BuffPtrArray[RX1Q_LN]; 
.................... static volatile PTR_STRUCT DestPtrStruct; 
....................  
.................... static volatile int16u MemFail,MemCount; 
....................  
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED FUNCTIONS                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             LOCAL FUNCTIONS                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... void main () 
*
0876:  MOV     #2780,W15
0878:  MOV     #27FF,W0
087A:  MOV     W0,20
087C:  NOP     
087E:  MOV     #4444,W0
0880:  MOV     W0,A8
0882:  BSET.B  81.7
0884:  MOV     #46,W0
0886:  MOV.B   W0L,742
0888:  MOV     #57,W0
088A:  MOV.B   W0L,742
088C:  BCLR.B  742.6
088E:  MOV     #3F0C,W0
0890:  MOV     W0,6A4
0892:  MOV     #1312,W0
0894:  MOV     W0,6C0
0896:  MOV     #300,W0
0898:  MOV     W0,6CC
089A:  MOV     #46,W0
089C:  MOV.B   W0L,742
089E:  MOV     #57,W0
08A0:  MOV.B   W0L,742
08A2:  BSET.B  742.6
08A4:  CLR     744
08A6:  MOV     #8000,W4
08A8:  MOV     W4,220
08AA:  MOV     #400,W4
08AC:  MOV     W4,222
08AE:  BSET.B  220.3
08B0:  MOV     #22,W4
08B2:  MOV     W4,228
08B4:  CLR     808
08B6:  BRA     8F0
08B8:  DATA    80,02,03
08BA:  DATA    2C,FF,FF
08BC:  DATA    80,02,07
08BE:  DATA    44,00,00
08C0:  DATA    80,02,08
08C2:  DATA    00,00,00
08C4:  DATA    80,02,08
08C6:  DATA    00,00,00
08C8:  DATA    C0,8F,08
08CA:  DATA    0A,00,80
08CC:  DATA    01,08,98
08CE:  DATA    00,C0,30
08D0:  DATA    08,9A,00
08D2:  DATA    00,00,00
08D4:  INC     W2,W2
08D6:  CP      W2,#1
08D8:  BRA     NZ,8E2
08DA:  TBLRDL  [W1],W3
08DC:  TBLRDH  [W1++],W4
08DE:  MOV.B   6,W0L
08E0:  RETURN  
08E2:  CP      W2,#2
08E4:  BRA     NZ,8EA
08E6:  MOV.B   7,W0L
08E8:  RETURN  
08EA:  MOV.B   8,W0L
08EC:  CLR     W2
08EE:  RETURN  
08F0:  MOV     #0,W6
08F2:  MOV     #0,W0
08F4:  MOV     W0,32
08F6:  MOV     #8B8,W0
08F8:  MOV     W0,W1
08FA:  CLR     W2
08FC:  CALL    8D4
0900:  MOV.B   W0L,B
0902:  CALL    8D4
0906:  MOV.B   W0L,A
0908:  CP0     W5
090A:  BRA     Z,93E
090C:  BTSS    W5.F
090E:  BRA     91E
0910:  CALL    8D4
0914:  MOV.B   W0L,D
0916:  CALL    8D4
091A:  MOV.B   W0L,C
091C:  BCLR    W5.F
091E:  BTSS    W5.E
0920:  BRA     932
0922:  BCLR    W5.E
0924:  DEC     W5,W5
0926:  CALL    8D4
092A:  MOV.B   W0L,W7L
092C:  REPEAT  W5
092E:  MOV.B   W7L,[W6++]
0930:  BRA     8FC
0932:  CALL    8D4
0936:  MOV.B   W0L,[W6++]
0938:  DEC     W5,W5
093A:  BRA     NZ,932
093C:  BRA     8FC
093E:  MOV     #93A,W4
0940:  MOV     W4,806
0942:  MOV     #1E42,W4
0944:  MOV     W4,93A
0946:  CLR     93C
.................... { 
.................... 	int8u errCode, SendTx1Count; 
.................... 	DisableIntr(); 
0948:  CALL    5FE
.................... 	HardwareInit(); 
094C:  CALL    608
.................... 	GlobalVarInit(); 
0950:  CALL    620
.................... 	DynamicMemInit(); 
0954:  CALL    636
.................... 	UARTQueueInit(); 
0958:  CALL    6DE
.................... 	EnableIntr(); 
095C:  CALL    700
.................... 	for (;;) 
.................... 	{ 
.................... 		/* code */ 
.................... 		DisableIntr(); 
0960:  CALL    5FE
.................... 		QPtrXGet(&Rx1QCB,&DestPtrStruct,&errCode); 
0964:  MOV     #8A8,W4
0966:  MOV     W4,8CC
0968:  MOV     #8C2,W4
096A:  MOV     W4,8CE
096C:  MOV     #8CA,W4
096E:  MOV     W4,8D0
0970:  CALL    708
.................... 		if(errCode == Q_OK) 
0974:  CP0.B   8CA
0976:  BRA     NZ,9A4
.................... 		{ 
.................... 			SendTx1Count = SendTx1((int8u *)DestPtrStruct.blockPtr); 
0978:  PUSH    8C2
097A:  POP     8CC
097C:  CALL    810
0980:  MOV.B   W0L,8CB
0982:  PUSH    42
0984:  BCLR.B  81.7
0986:  SETM.B  42
0988:  BSET.B  81.7
.................... 			free ((void *)DestPtrStruct.blockPtr); 
098A:  PUSH    8C2
098C:  POP     908
098E:  CALL    326
0992:  BCLR.B  81.7
0994:  POP     42
0996:  BSET.B  81.7
.................... 			MemCount--; 
0998:  DEC     08C6
.................... 			EnableIntr(); 
099A:  CALL    700
.................... 			if (SendTx1Count == 0) 
099E:  CP0.B   8CB
09A0:  BRA     NZ,9A2
.................... 			{ 
.................... 				/* code */ 
.................... 				//output_low(LED3); 
.................... 			} 
.................... 		} 
09A2:  BRA     9A8
.................... 		else 
.................... 		{ 
.................... 			EnableIntr(); 
09A4:  CALL    700
.................... 		} 
09A8:  BRA     960
.................... 	} 
.................... } 
....................  
09AA:  PWRSAV  #0
.................... /****************************************************************************/ 
.................... static void HardwareInit() 
*
0608:  MOV     W5,[W15++]
.................... { 
.................... 	setup_adc_ports(NO_ANALOGS); 
060A:  SETM    32C
.................... 	set_tris_a(get_tris_a () & 0xffeb); 
060C:  MOV     2C0,W5
060E:  MOV     #FFEB,W0
0610:  AND     W0,W5,W5
0612:  MOV     W5,2C0
.................... 	set_tris_b(get_tris_b () & 0xfff3); 
0614:  MOV     2C8,W5
0616:  MOV     #FFF3,W0
0618:  AND     W0,W5,W5
061A:  MOV     W5,2C8
061C:  MOV     [--W15],W5
061E:  RETURN  
.................... //	output_high(LED0); 
.................... //	output_high(LED1); 
.................... 	//output_high(LED2); 
.................... //	output_high(LED3); 
....................  
.................... } 
.................... static void GlobalVarInit() 
.................... { 
.................... 	Tx1Flag = TX1_READY; 
0620:  BSET.B  898.0
.................... 	Tx1BuffIdx = 0; 
0622:  CLR     896
.................... 	Tx1FrameIn = 0; 
0624:  CLR     89A
.................... 	Tx1FrameOut = 0; 
0626:  CLR     89C
.................... 	Tx1QFullCount = 0; 
0628:  CLR     8A2
.................... 	Rx1FrameCount = 0; 
062A:  CLR     89E
.................... 	RxCount = 0; 
062C:  CLR     8A0
.................... 	Rx1QFullCount = 0; 
062E:  CLR     8A4
.................... 	MemFail = 0; 
0630:  CLR     8C4
.................... 	MemCount = 0; 
0632:  CLR     8C6
.................... 	return; 
0634:  RETURN  
.................... } 
....................  
.................... static void DynamicMemInit() 
0636:  PUSH    42
0638:  BCLR.B  81.7
063A:  SETM.B  42
063C:  BSET.B  81.7
.................... { 
.................... 	RxBuffPtr = (int8u *)malloc ((sizeof (int8u)) * RX_CMND_FRM_LN); 
063E:  MOV     #10,W4
0640:  MOV     W4,90A
0642:  CALL    3C0
0646:  BCLR.B  81.7
0648:  POP     42
064A:  BSET.B  81.7
064C:  MOV     W0,8A6
.................... 	if (RxBuffPtr != (int8u *)NULL) 
064E:  CP0     8A6
0650:  BRA     Z,65E
.................... 	{ 
.................... 		MemCount++; 
0652:  INC     08C6
.................... 		clear_interrupt(INT_RDA); 
0654:  REPEAT  #3
0656:  MOV     226,W0
0658:  BCLR.B  85.3
.................... 		enable_interrupts(INT_RDA); 
065A:  BSET.B  95.3
.................... 	} 
065C:  BRA     660
.................... 	else 
.................... 	{ 
.................... 		MemFail++; 
065E:  INC     08C4
.................... 	} 
.................... 	return; 
0660:  RETURN  
.................... } 
....................  
.................... static void UARTQueueInit() 
.................... { 
.................... 	QPtrXInit(&Rx1QCB, Rx1BuffPtrArray, RX1Q_LN);  
*
06DE:  MOV     #8A8,W4
06E0:  MOV     W4,8CC
06E2:  MOV     #8B2,W4
06E4:  MOV     W4,8CE
06E6:  MOV     #8,W4
06E8:  MOV     W4,8D0
06EA:  CALL    662
.................... 	Q8UXInit(&Tx1QCB,Tx1QArray,TX1Q_LN); 
06EE:  MOV     #80A,W4
06F0:  MOV     W4,8CC
06F2:  MOV     #814,W4
06F4:  MOV     W4,8CE
06F6:  MOV     #80,W4
06F8:  MOV     W4,8D0
06FA:  CALL    6A0
.................... 	return; 
06FE:  RETURN  
.................... } 
.................... static int8u SendTx1 (int8u *strPtr) 
*
0810:  MOV     W5,[W15++]
.................... { 
.................... 	int8u strLn; 
.................... 	int8u strIdx; 
.................... 	int16u qSpace; 
.................... 	int8u errCode; 
.................... 	int8u count; 
.................... 		count = 0; 
0812:  CLR.B   8D3
.................... 		strLn = strlen(strPtr); 
0814:  PUSH    8CC
0816:  POP     8D6
0818:  CALL    772
081C:  MOV.B   W0L,8CE
.................... 		if (strLn != 0) 
081E:  CP0.B   8CE
0820:  BRA     Z,870
.................... 		{ 
.................... 			/* code */ 
.................... 			qSpace = TX1Q_LN - Q8UXCount(&Tx1QCB); 
0822:  MOV     #80A,W4
0824:  MOV     W4,8D6
0826:  CALL    794
082A:  MOV     #80,W4
082C:  SUB     W4,W0,W0
082E:  MOV     W0,8D0
.................... 			if (qSpace >= (int16u)strLn) 
0830:  MOV.B   8CE,W0L
0832:  CLR.B   1
0834:  MOV     8D0,W4
0836:  CP      W4,W0
0838:  BRA     NC,870
.................... 			{ 
.................... 				/* code */ 
.................... 				for(strIdx = 0; strIdx < strLn; strIdx++) 
083A:  CLR.B   8CF
083C:  MOV.B   8CF,W0L
083E:  MOV     8CE,W4
0840:  CP.B    W4L,W0L
0842:  BRA     LEU,866
.................... 				{ 
.................... 					Q8UXPut(&Tx1QCB,strPtr[strIdx],&errCode); 
0844:  MOV     8CE,W4
0846:  LSR     W4,#8,W4
0848:  MOV     W4,W0
084A:  ADD     8CC,W0
084C:  MOV.B   [W0],W5L
084E:  PUSH    8DA
0850:  MOV.B   W5L,[W15-#2]
0852:  POP     8DA
0854:  MOV     #80A,W4
0856:  MOV     W4,8D8
0858:  MOV     #8D2,W4
085A:  MOV     W4,8DC
085C:  CALL    7A4
.................... 					count++; 
0860:  INC.B   08D3
0862:  INC.B   08CF
0864:  BRA     83C
.................... 				} 
.................... 				if(Tx1Flag == TX1_READY) 
0866:  BTSS.B  898.0
0868:  BRA     870
.................... 				{ 
.................... 					Tx1Flag = TX1_BUSY; 
086A:  BCLR.B  898.0
.................... 					TX1IF = 1; 
086C:  BSET.B  85.4
.................... 					enable_interrupts(INT_TBE); 
086E:  BSET.B  95.4
.................... 				} 
.................... 			} 
.................... 		} 
.................... 		return count; 
0870:  MOV.B   8D3,W0L
0872:  MOV     [--W15],W5
0874:  RETURN  
.................... } 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                                 Interrupt Functions                                   **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #INT_RDA 
.................... void RDA1() 
*
0472:  PUSH    42
0474:  PUSH    36
0476:  PUSH    32
0478:  MOV     W0,[W15++]
047A:  MOV     #2,W0
047C:  REPEAT  #C
047E:  MOV     [W0++],[W15++]
.................... { 
.................... 	static FRAME_STATE FrameState = FRAME_WAIT; 
.................... 	static int16u FrmIdx = 0; 
.................... 	int8u Chr; 
.................... 	int8u *errCode; 
.................... 		Chr = getc(); 
0480:  BTSS.B  222.0
0482:  BRA     480
0484:  MOV     226,W0
0486:  MOV.B   W0L,8FE
.................... 		RxCount++; 
0488:  INC     08A0
.................... 		switch(FrameState) 
048A:  CLR     W0
048C:  BTSC.B  898.1
048E:  INC     W0,W0
0490:  CLR.B   1
0492:  XOR     #0,W0
0494:  BRA     Z,49C
0496:  XOR     #1,W0
0498:  BRA     Z,4B2
049A:  BRA     542
.................... 		{ 
.................... 			case FRAME_WAIT: 
.................... 				if(Chr == START_CHR) 
049C:  MOV     8FE,W4
049E:  XOR.B   #3C,W4L
04A0:  BRA     NZ,4B0
.................... 				{ 
.................... 					RxBuffPtr[FrmIdx] = Chr; 
04A2:  MOV     8C8,W0
04A4:  ADD     8A6,W0
04A6:  MOV     W0,W5
04A8:  MOV     8FE,W0
04AA:  MOV.B   W0L,[W5+#0]
.................... 					FrmIdx++; 
04AC:  INC     08C8
.................... 					FrameState = FRAME_PROGRESS; 
04AE:  BSET.B  898.1
.................... 				} 
.................... 				break; 
04B0:  BRA     544
.................... 			case  FRAME_PROGRESS: 
.................... 				if(Chr == START_CHR) 
04B2:  MOV     8FE,W4
04B4:  XOR.B   #3C,W4L
04B6:  BRA     NZ,4C8
.................... 				{ 
.................... 					FrmIdx = 0; 
04B8:  CLR     8C8
.................... 					RxBuffPtr[FrmIdx] = Chr; 
04BA:  MOV     8C8,W0
04BC:  ADD     8A6,W0
04BE:  MOV     W0,W5
04C0:  MOV     8FE,W0
04C2:  MOV.B   W0L,[W5+#0]
.................... 					FrmIdx++; 
04C4:  INC     08C8
.................... 				} 
04C6:  BRA     540
.................... 				else if((FrmIdx == (RX_CMND_FRM_LN-2)) && (Chr != END_CHR)) 
04C8:  MOV     8C8,W4
04CA:  CP      W4,#E
04CC:  BRA     NZ,4DA
04CE:  MOV     8FE,W4
04D0:  XOR.B   #3E,W4L
04D2:  BRA     Z,4DA
.................... 				{ 
.................... 					FrmIdx = 0; 
04D4:  CLR     8C8
.................... 					FrameState = FRAME_WAIT; 
04D6:  BCLR.B  898.1
.................... 				} 
04D8:  BRA     540
.................... 				else if (Chr == END_CHR) 
04DA:  MOV     8FE,W4
04DC:  XOR.B   #3E,W4L
04DE:  BRA     NZ,534
.................... 				{ 
.................... 					/* code */ 
.................... 					RxBuffPtr[FrmIdx] = Chr; 
04E0:  MOV     8C8,W0
04E2:  ADD     8A6,W0
04E4:  MOV     W0,W5
04E6:  MOV     8FE,W0
04E8:  MOV.B   W0L,[W5+#0]
.................... 					FrmIdx++; 
04EA:  INC     08C8
.................... 					RxBuffPtr[FrmIdx] = 0; 
04EC:  MOV     8C8,W0
04EE:  ADD     8A6,W0
04F0:  MOV     W0,W5
04F2:  CLR.B   [W5]
.................... 					FrmIdx = 0; 
04F4:  CLR     8C8
.................... 					Rx1FrameCount++; 
04F6:  INC     089E
....................  
.................... 					QPtrXPut(&Rx1QCB,(void *)RxBuffPtr, &errCode); 
04F8:  MOV     #8A8,W4
04FA:  MOV     W4,90E
04FC:  PUSH    8A6
04FE:  POP     910
0500:  MOV     #900,W4
0502:  MOV     W4,912
0504:  CALL    200
.................... 					if (errCode == Q_FULL) 
0508:  MOV     900,W4
050A:  CP      W4,#1
050C:  BRA     NZ,51A
.................... 					{ 
.................... 						/* code */ 
.................... 						free((void *)RxBuffPtr); 
050E:  PUSH    8A6
0510:  POP     908
0512:  CALL    326
.................... 						MemCount--; 
0516:  DEC     08C6
.................... 						Rx1QFullCount++; 
0518:  INC     08A4
.................... 					} 
.................... 					FrameState = FRAME_WAIT; 
051A:  BCLR.B  898.1
....................  
.................... 					RxBuffPtr = (int8u *)malloc((sizeof (int8u)) * RX_CMND_FRM_LN); 
051C:  MOV     #10,W4
051E:  MOV     W4,90A
0520:  CALL    3C0
0524:  MOV     W0,8A6
.................... 					if(RxBuffPtr == (int8u *)NULL) 
0526:  CP0     8A6
0528:  BRA     NZ,530
.................... 					{ 
.................... 						disable_interrupts(INT_RDA); 
052A:  BCLR.B  95.3
.................... 						MemFail++; 
052C:  INC     08C4
.................... 					} 
052E:  BRA     532
.................... 					else 
.................... 					{ 
.................... 						MemCount++; 
0530:  INC     08C6
.................... 					} 
.................... 				} 
0532:  BRA     540
.................... 				else 
.................... 				{ 
.................... 					RxBuffPtr[FrmIdx] = Chr; 
0534:  MOV     8C8,W0
0536:  ADD     8A6,W0
0538:  MOV     W0,W5
053A:  MOV     8FE,W0
053C:  MOV.B   W0L,[W5+#0]
.................... 					FrmIdx++; 
053E:  INC     08C8
.................... 				} 
.................... 				break; 
0540:  BRA     544
.................... 			default: 
.................... 				break; 
0542:  BRA     544
.................... 		} 
.................... 		return; 
.................... } 
....................  
0544:  BCLR.B  85.3
0546:  MOV     #1A,W0
0548:  REPEAT  #C
054A:  MOV     [--W15],[W0--]
054C:  MOV     [--W15],W0
054E:  POP     32
0550:  POP     36
0552:  POP     42
0554:  RETFIE  
.................... #INT_TBE 
.................... void TBE1ISR() 
*
05BA:  BCLR.B  85.4
05BC:  PUSH    42
05BE:  PUSH    36
05C0:  PUSH    32
05C2:  MOV     W0,[W15++]
05C4:  MOV     #2,W0
05C6:  REPEAT  #C
05C8:  MOV     [W0++],[W15++]
.................... { 
.................... 	int8u destChr; 
.................... 	Q_ERR errCode; 
.................... 		Q8UXGet (&Tx1QCB, &destChr,&errCode); 
05CA:  MOV     #80A,W4
05CC:  MOV     W4,900
05CE:  MOV     #8FE,W4
05D0:  MOV     W4,902
05D2:  MOV     #8FF,W4
05D4:  MOV     W4,904
05D6:  CALL    556
.................... 		if (errCode == Q_OK) 
05DA:  CP0.B   8FF
05DC:  BRA     NZ,5EA
.................... 		{ 
.................... 			/* code */ 
.................... 			putc(destChr); 
05DE:  MOV.B   8FE,W0L
05E0:  BTSC.B  223.1
05E2:  BRA     5E0
05E4:  MOV.B   W0L,224
05E6:  CLR.B   225
.................... 		} 
05E8:  BRA     5EE
.................... 		else 
.................... 		{ 
.................... 			disable_interrupts(INT_TBE); 
05EA:  BCLR.B  95.4
.................... 			Tx1Flag = TX1_READY; 
05EC:  BSET.B  898.0
.................... 		} 
.................... 		return; 
05EE:  MOV     #1A,W0
05F0:  REPEAT  #C
05F2:  MOV     [--W15],[W0--]
05F4:  MOV     [--W15],W0
05F6:  POP     32
05F8:  POP     36
05FA:  POP     42
05FC:  RETFIE  
.................... } 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                                 EOF                                    **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9C7   NOPR NOALTI2C1 NOIOL1WAY OSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
